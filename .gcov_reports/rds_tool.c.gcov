        -:    0:Source:rds_tool.c
        -:    1:/*
        -:    2: * JMPXRDS, an FM MPX signal generator with RDS support on
        -:    3: * top of Jack Audio Connection Kit - RDS runtime configuration tool
        -:    4: *
        -:    5: * Copyright (C) 2015 Nick Kossifidis <mickflemm@gmail.com>
        -:    6: *
        -:    7: * This program is free software: you can redistribute it and/or modify
        -:    8: * it under the terms of the GNU General Public License as published by
        -:    9: * the Free Software Foundation, either version 3 of the License, or
        -:   10: * (at your option) any later version.
        -:   11: *
        -:   12: * This program is distributed in the hope that it will be useful,
        -:   13: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15: * GNU General Public License for more details.
        -:   16: *
        -:   17: * You should have received a copy of the GNU General Public License
        -:   18: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19: */
        -:   20:#include "rds_encoder.h"
        -:   21:#include "utils.h"
        -:   22:#include <stdlib.h>		/* For atoi / strtol */
        -:   23:#include <stdio.h>		/* For snprintf */
        -:   24:#include <string.h>		/* For memset / strnlen / strncmp */
        -:   25:#include <getopt.h>		/* For getopt_long_only() */
        -:   26:#include <signal.h>		/* For signal handling / sig_atomic_t */
        -:   27:
        -:   28:#define TEMP_BUF_LEN	RDS_RT_LENGTH + 1
        -:   29:
        1:   30:void usage(char *name)
        -:   31:{
        1:   32:	utils_ann("RDS Configuration tool for JMPXRDS\n");
        1:   33:	utils_info("Usage: %s -g or [<parameter> <value>] pairs\n", name);
        1:   34:	utils_info("\nParameters:\n"
        -:   35:		"\t-g\t\tGet current config\n"
        -:   36:		"\t-e          \tEnable RDS encoder\n"
        -:   37:		"\t-d          \tDisable RDS encoder\n"
        -:   38:		"\t-rt   <text>\tSet radiotext\n"
        -:   39:		"\t-ps   <text>\tSet Programme Service Name (PSN)\n"
        -:   40:		"\t-pi   <hex>\tSet Programme Identifier (PI)\n"
        -:   41:		"\t-pty  <int>\tSet Programme Type (PTY)\n"
        -:   42:		"\t-ptyn <text>\tSet Programme Type Name (PTYN)\n"
        -:   43:		"\t-ecc  <hex>\tSet Extended Country Code (ECC)\n"
        -:   44:		"\t-lic  <hex>\tSet Language Identifier Code (LIC)\n"
        -:   45:		"\t-tp   <bool>\tSet Traffic Programme flag (TP)\n"
        -:   46:		"\t-ta   <bool>\tSet Traffic Announcement flag (TA)\n"
        -:   47:		"\t-ms   <bool>\tSet Music/Speech flag (MS)\n"
        -:   48:		"\t-di   <hex>\tSet Decoder Info (DI)\n"
        -:   49:		"\t-dps  <filename>\tUpdate PSN from file (Dynamic PSN)\n"
        -:   50:		"\t-drt  <filename>\tUpdate RT from file (Dynamic RT)\n");
        1:   51:}
        -:   52:
        -:   53:static const struct option opts[] = {
        -:   54:	{"rt",	required_argument,0,	1},
        -:   55:	{"ps",	required_argument,0,	2},
        -:   56:	{"pi",	required_argument,0,	3},
        -:   57:	{"pty",	required_argument,0,	4},
        -:   58:	{"ptyn", required_argument,0,	5},
        -:   59:	{"ecc",	required_argument,0,	6},
        -:   60:	{"lic",	required_argument,0,	7},
        -:   61:	{"tp",	required_argument,0,	8},
        -:   62:	{"ta",	required_argument,0,	9},
        -:   63:	{"ms",	required_argument,0,	10},
        -:   64:	{"di",	required_argument,0,	11},
        -:   65:	{"dps",	required_argument,0,	12},
        -:   66:	{"drt",	required_argument,0,	13},
        -:   67:	{0,	0,		0,	0}
        -:   68:};
        -:   69:
        -:   70:static volatile sig_atomic_t active;
        -:   71:
        -:   72:static void
        1:   73:signal_handler(__attribute__((unused)) int sig,
        -:   74:	       __attribute__((unused)) siginfo_t *info,
        -:   75:	       __attribute__((unused))void *context)
        -:   76:{
        1:   77:	active = 0;
        1:   78:	return;
        -:   79:}
        -:   80:
        -:   81:int
        3:   82:main(int argc, char *argv[])
        -:   83:{
        3:   84:	int ret = 0;
        3:   85:	uint16_t pi = 0;
        3:   86:	uint8_t pty = 0;
        3:   87:	uint8_t ecc = 0;
        3:   88:	uint16_t lic = 0;
        3:   89:	uint8_t tp = 0;
        3:   90:	uint8_t ta = 0;
        3:   91:	uint8_t ms = 0;
        3:   92:	uint8_t di = 0;
        3:   93:	char temp[TEMP_BUF_LEN] = {0};
        3:   94:	struct shm_mapping *shmem = NULL;
        3:   95:	struct rds_encoder_state *st = NULL;
        3:   96:	struct rds_dynps_state dps = {0};
        3:   97:	struct rds_dynrt_state drt = {0};
        -:   98:	struct sigaction sa;
        3:   99:	int loop = 0;
        3:  100:	int opt = 0;
        3:  101:	int opt_idx = 0;
        -:  102:
        3:  103:	shmem = utils_shm_attach(RDS_ENC_SHM_NAME,
        -:  104:				 sizeof(struct rds_encoder_state));
        3:  105:	if (!shmem) {
    #####:  106:		utils_perr("Unable to communicate with the RDS encoder");
    #####:  107:		return -1;
        -:  108:	}
        3:  109:	st = (struct rds_encoder_state*) shmem->mem;
        -:  110:
       16:  111:	while ((opt = getopt_long_only(argc, argv,"ged", opts, &opt_idx)) != -1) {
       13:  112:		switch(opt) {
        1:  113:		case 'g':
       2*:  114:			utils_info("Current config:\n"
        -:  115:				"\tStatus: %s\n"
        -:  116:				"\tPI:   0x%X\n"
        -:  117:				"\tECC:  0x%X\n"
        -:  118:				"\tLIC:  0x%X\n"
        -:  119:				"\tPTY:  %i\n"
        -:  120:				"\tPSN:   %s\n"
        -:  121:				"\tRT:   %s\n"
        -:  122:				"\tPTYN: %s\n"
        -:  123:				"\tTP: 0x%X\n"
        -:  124:				"\tTA: 0x%X\n"
        -:  125:				"\tMS: 0x%X\n"
        -:  126:				"\tDI: 0x%X\n",
        1:  127:				st->enabled ? "Enabled" : "Disabled",
        1:  128:				rds_get_pi(st),
        1:  129:				rds_get_ecc(st),
        1:  130:				rds_get_lic(st),
        1:  131:				rds_get_pty(st),
        -:  132:				rds_get_ps(st),
        1:  133:				st->rt_set ? rds_get_rt(st) : "<Not set>",
        1:  134:				st->ptyn_set ? rds_get_ptyn(st) : "<Not set>",
        1:  135:				rds_get_tp(st),
        1:  136:				rds_get_ta(st),
        1:  137:				rds_get_ms(st),
        1:  138:				rds_get_di(st));
        1:  139:			break;
        1:  140:		case 'e':
        1:  141:			st->enabled = 1;
        1:  142:			utils_info("RDS encoder enabled\n");
        1:  143:			break;
    #####:  144:		case 'd':
    #####:  145:			st->enabled = 0;
    #####:  146:			utils_info("RDS encoder disabled\n");
    #####:  147:			break;
        1:  148:		case 1:	/* RadioText */
        1:  149:			memset(temp, 0, TEMP_BUF_LEN);
        1:  150:			snprintf(temp, RDS_RT_LENGTH + 1, "%s", optarg);
        1:  151:			ret = rds_set_rt(st, temp, 1);
        1:  152:			if (ret < 0) {
    #####:  153:				utils_err("Failed to set RT !\n");
    #####:  154:				goto cleanup;
        -:  155:			} else
        1:  156:				utils_info("RT set:  \t%s\n", temp);
        1:  157:			break;
    #####:  158:		case 2:	/* Programme Service Name */
    #####:  159:			memset(temp, 0, TEMP_BUF_LEN);
    #####:  160:			snprintf(temp, RDS_PS_LENGTH + 1, "%s", optarg);
    #####:  161:			ret = rds_set_ps(st, temp);
    #####:  162:			if (ret < 0) {
    #####:  163:				utils_err("Failed to set PS !\n");
    #####:  164:				goto cleanup;
        -:  165:			} else
    #####:  166:				utils_info("PS set:  \t%s\n", temp);
    #####:  167:			break;
        1:  168:		case 3:	/* Programme Identifier */
        1:  169:			memset(temp, 0, TEMP_BUF_LEN);
        1:  170:			snprintf(temp, 7, "%s", optarg);
        1:  171:			pi = (uint16_t) strtol(temp, NULL, 16);
        1:  172:			ret = rds_set_pi(st, pi);
        1:  173:			if (ret < 0) {
    #####:  174:				utils_err("Failed to set PI !\n");
    #####:  175:				goto cleanup;
        -:  176:			} else
        1:  177:				utils_info("PI set:  \t0x%X\n", pi);
        1:  178:			break;
    #####:  179:		case 4:	/* Programme Type */
    #####:  180:			memset(temp, 0, TEMP_BUF_LEN);
    #####:  181:			snprintf(temp, 4, "%s", optarg);
    #####:  182:			pty = (uint8_t) atoi(temp);
    #####:  183:			ret = rds_set_pty(st, pty);
    #####:  184:			if (ret < 0) {
    #####:  185:				utils_err("Failed to set PTY !\n");
    #####:  186:				goto cleanup;
        -:  187:			} else
    #####:  188:				utils_info("PTY set:\t%i\n", pty);
    #####:  189:			break;
        1:  190:		case 5:	/* Programme Type Name */
        1:  191:			memset(temp, 0, TEMP_BUF_LEN);
        1:  192:			snprintf(temp, RDS_PTYN_LENGTH + 1, "%s", optarg);
        1:  193:			ret = rds_set_ptyn(st, temp);
        1:  194:			if (ret < 0) {
    #####:  195:				utils_err("Failed to set PTYN !\n");
    #####:  196:				goto cleanup;
        -:  197:			} else
        1:  198:				utils_info("PTYN set:\t%s\n", temp);
        1:  199:			break;
        1:  200:		case 6:	/* Extended Country Code */
        1:  201:			memset(temp, 0, TEMP_BUF_LEN);
        1:  202:			snprintf(temp, 5, "%s", optarg);
        1:  203:			ecc = (uint8_t) strtol(temp, NULL, 16);
        1:  204:			ret = rds_set_ecc(st, ecc);
        1:  205:			if (ret < 0) {
    #####:  206:				utils_err("Failed to set ECC !\n");
    #####:  207:				goto cleanup;
        -:  208:			} else
        1:  209:				utils_info("ECC set:  \t0x%X\n", ecc);
        1:  210:			break;
        1:  211:		case 7:	/* Language Identifier Code */
        1:  212:			memset(temp, 0, TEMP_BUF_LEN);
        1:  213:			snprintf(temp, 6, "%s", optarg);
        1:  214:			lic = (uint16_t) strtol(temp, NULL, 16);
        1:  215:			lic &= 0xFFF;
        1:  216:			ret = rds_set_lic(st, lic);
        1:  217:			if (ret < 0) {
    #####:  218:				utils_err("Failed to set LIC !\n");
    #####:  219:				goto cleanup;
        -:  220:			} else
        1:  221:				utils_info("LIC set:  \t0x%X\n", lic);
        1:  222:			break;
        1:  223:		case 8:	/* Traffic Programme */
        1:  224:			memset(temp, 0, TEMP_BUF_LEN);
        1:  225:			snprintf(temp, 2, "%s", optarg);
        1:  226:			tp = strtol(temp, NULL, 2) ? 1 : 0;
        1:  227:			ret = rds_set_tp(st, tp);
        1:  228:			if (ret < 0) {
    #####:  229:				utils_err("Failed to set TP !\n");
    #####:  230:				goto cleanup;
        -:  231:			} else
        1:  232:				utils_info("TP set:  \t0x%X\n", tp);
        1:  233:			break;
        1:  234:		case 9:	/* Traffic Announcement */
        1:  235:			memset(temp, 0, TEMP_BUF_LEN);
        1:  236:			snprintf(temp, 2, "%s", optarg);
        1:  237:			ta = strtol(temp, NULL, 2) ? 1 : 0;
        1:  238:			ret = rds_set_ta(st, ta);
        1:  239:			if (ret < 0) {
    #####:  240:				utils_err("Failed to set TA !\n");
    #####:  241:				goto cleanup;
        -:  242:			} else
        1:  243:				utils_info("TA set:  \t0x%X\n", ta);
        1:  244:			break;
        1:  245:		case 10:/* Music/Speech flag */
        1:  246:			memset(temp, 0, TEMP_BUF_LEN);
        1:  247:			snprintf(temp, 2, "%s", optarg);
        1:  248:			ms = strtol(temp, NULL, 2) ? 1 : 0;
        1:  249:			ret = rds_set_ms(st, ms);
        1:  250:			if (ret < 0) {
    #####:  251:				utils_err("Failed to set MS !\n");
    #####:  252:				goto cleanup;
        -:  253:			} else
        1:  254:				utils_info("MS set:  \t0x%X\n", ms);
        1:  255:			break;
        1:  256:		case 11:/* Decoder Info */
        1:  257:			memset(temp, 0, TEMP_BUF_LEN);
        1:  258:			snprintf(temp, 2, "%s", optarg);
        1:  259:			di = strtol(temp, NULL, 16);
        1:  260:			di &= 0xF;
        1:  261:			ret = rds_set_di(st, di);
        1:  262:			if (ret < 0) {
    #####:  263:				utils_err("Failed to set MS !\n");
    #####:  264:				goto cleanup;
        -:  265:			} else
        1:  266:				utils_info("MS set:  \t0x%X\n", di);
        1:  267:			break;
        1:  268:		case 12: /* Dynamic PSN */
        1:  269:			ret = rds_dynps_init(&dps, st, optarg);
        1:  270:			if(ret < 0) {
    #####:  271:				utils_err("Failed to initialize Dynamic PSN mode !\n");
    #####:  272:				goto cleanup;
        -:  273:			} else
        1:  274:				loop = 1;
        1:  275:			break;
        1:  276:		case 13: /* Dynamic RT */
        1:  277:			ret = rds_dynrt_init(&drt, st, optarg);
        1:  278:			if(ret < 0) {
    #####:  279:				utils_err("Failed to initialize Dynamic RT mode !\n");
    #####:  280:				goto cleanup;
        -:  281:			} else
        1:  282:				loop = 1;
        1:  283:			break;
    #####:  284:		default:
    #####:  285:			usage(argv[0]);
    #####:  286:			utils_shm_destroy(shmem, 0);
    #####:  287:			return -1;
        -:  288:		}
        -:  289:	}
        -:  290:
        3:  291:	if (argc < 2 || (argc > 1 && optind == 1)) {
        1:  292:		usage(argv[0]);
        1:  293:		ret = -1;
        -:  294:	}
        -:  295:
        3:  296:	if(loop) {
        -:  297:		/* Install a signal handler for graceful exit */
        1:  298:		memset(&sa, 0, sizeof(struct sigaction));
        1:  299:		sigemptyset(&sa.sa_mask);
        1:  300:		sa.sa_flags = SA_SIGINFO;
        1:  301:		sa.sa_sigaction = signal_handler;
        1:  302:		sigaction(SIGQUIT, &sa, NULL);
        1:  303:		sigaction(SIGTERM, &sa, NULL);
        1:  304:		sigaction(SIGINT, &sa, NULL);
        1:  305:		active = 1;
830733608:  306:		while(active);
        1:  307:		rds_dynps_destroy(&dps);
        1:  308:		rds_dynrt_destroy(&drt);
        -:  309:	}
        -:  310:
        2:  311: cleanup:
        3:  312:	utils_shm_destroy(shmem, 0);
        3:  313:	return ret;
        -:  314:}

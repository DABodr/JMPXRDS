        -:    0:Source:gui/jmrg_display_field.c
        -:    1:#include <stdlib.h> /* For malloc() / free() */
        -:    2:#include <string.h> /* For memset() */
        -:    3:#include "jmpxrds_gui.h"
        -:    4:#include "rds_codes.h"
        -:    5:
        -:    6:/******************\
        -:    7:* POLLING FUNCTION *
        -:    8:\******************/
        -:    9:
        -:   10:static gboolean
     2272:   11:jmrg_display_field_poll(gpointer data)
        -:   12:{
     2272:   13:	struct value_map *vmap = (struct value_map*) data;
     2272:   14:	struct rds_encoder_state *st = vmap->st;
     2272:   15:	char pi[8] = {0};
     2272:   16:	char *text = NULL;
     2272:   17:	const char *def_ptyn = NULL;
     2272:   18:	char ptyn[24] = {0};
     2272:   19:	int tmp = 0;
        -:   20:
    2272*:   21:	if(!GTK_IS_LABEL(vmap->target))
    #####:   22:		return FALSE;
        -:   23:
     2272:   24:	if(!gtk_widget_is_visible(vmap->target))
      712:   25:		return TRUE;
        -:   26:
     1560:   27:	switch(vmap->type) {
      390:   28:	case RDS_FIELD_PI:
      390:   29:		tmp = rds_get_pi(st);
      390:   30:		snprintf(pi, 5, "%X", st->pi);
      390:   31:		gtk_label_set_text(GTK_LABEL(vmap->target), pi);
      390:   32:		return TRUE;
      390:   33:	case RDS_FIELD_PS:
      390:   34:		if(!st->ps_set)
       24:   35:			return TRUE;
      366:   36:		text = rds_get_ps(st);
      366:   37:		if(gtk_widget_get_sensitive(vmap->target2) == FALSE)
        1:   38:			gtk_widget_set_sensitive(vmap->target2, TRUE);
      366:   39:		break;
      390:   40:	case RDS_FIELD_RT:
      390:   41:		if(!st->rt_set)
       84:   42:			return TRUE;
      306:   43:		text = rds_get_rt(st);
      306:   44:		if(gtk_widget_get_sensitive(vmap->target2) == FALSE)
        1:   45:			gtk_widget_set_sensitive(vmap->target2, TRUE);
      306:   46:		break;
      390:   47:	case RDS_FIELD_PTYN:
      390:   48:		if(!st->ptyn_set)
       97:   49:			return TRUE;
      293:   50:		text = rds_get_ptyn(st);
      293:   51:		if(!text) {
    #####:   52:			tmp = rds_get_pty(st);
    #####:   53:			def_ptyn = rds_codes_get_pty_name(tmp);
    #####:   54:			snprintf(ptyn, 24, "( %s )", def_ptyn);
    #####:   55:			text = ptyn;
        -:   56:		}
      293:   57:		break;
    #####:   58:	default:
    #####:   59:		return FALSE;
        -:   60:	}
        -:   61:
      965:   62:	if(text)
      965:   63:		gtk_label_set_text(GTK_LABEL(vmap->target), text);
        -:   64:
      965:   65:	return TRUE;
        -:   66:}
        -:   67:
        -:   68:
        -:   69:/*************\
        -:   70:* ENTRY POINT *
        -:   71:\*************/
        -:   72:
        -:   73:GtkWidget*
        4:   74:jmrg_display_field_init(struct rds_encoder_state *st, const char* label, int type)
        -:   75:{
        4:   76:	GtkWidget *container = NULL;
        4:   77:	GtkWidget *vbox = NULL;
        4:   78:	GtkWidget *display = NULL;
        4:   79:	GtkWidget *input_hbox = NULL;
        4:   80:	GtkWidget *input = NULL;
        4:   81:	GtkWidget *flag_check = NULL;
        4:   82:	GtkWidget *set_button = NULL;
        4:   83:	GtkWidget *file_chooser = NULL;
        4:   84:	GtkStyleContext *context = NULL;
        4:   85:	struct value_map *vmap = NULL;
        4:   86:	int has_flag = 0;
        4:   87:	int is_dynamic = 0;
        4:   88:	int max_len = 1;
        -:   89:
        4:   90:	switch(type) {
        1:   91:		case RDS_FIELD_PI:
        1:   92:			max_len = 5;
        1:   93:			break;
        1:   94:		case RDS_FIELD_PS:
        1:   95:			max_len = RDS_PS_LENGTH;
        1:   96:			is_dynamic = 1;
        1:   97:			break;
        1:   98:		case RDS_FIELD_RT:
        1:   99:			max_len = RDS_RT_LENGTH;
        1:  100:			has_flag = 1;
        1:  101:			is_dynamic = 1;
        1:  102:			break;
        1:  103:		case RDS_FIELD_PTYN:
        1:  104:			max_len = RDS_PTYN_LENGTH;
        1:  105:			break;
    #####:  106:		default:
    #####:  107:			return NULL;
        -:  108:	};
        -:  109:
        -:  110:
        -:  111:	/* Use a frame to also have a label there
        -:  112:	 * for free */
        4:  113:	container = gtk_frame_new(label);
        4:  114:	if(!container)
    #####:  115:		goto cleanup;
        4:  116:	gtk_frame_set_label_align(GTK_FRAME(container), 0.5, 0.6);
        4:  117:	if(label != NULL)
        4:  118:		gtk_frame_set_shadow_type(GTK_FRAME(container),
        -:  119:					  GTK_SHADOW_ETCHED_IN);
        -:  120:	else
    #####:  121:		gtk_frame_set_shadow_type(GTK_FRAME(container),
        -:  122:					  GTK_SHADOW_NONE);
        4:  123:	gtk_widget_set_valign(container, GTK_ALIGN_START);
        -:  124:
        -:  125:
        -:  126:	/* Use a box to have better control */
        4:  127:	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        4:  128:	if(!vbox)
    #####:  129:		goto cleanup;
        4:  130:	gtk_container_add(GTK_CONTAINER(container), vbox);
        -:  131:
        -:  132:	/* Create the display as a label widget */
        4:  133:	display  = gtk_label_new(NULL);
        4:  134:	if(!display)
    #####:  135:		goto cleanup;
        4:  136:	gtk_box_pack_start(GTK_BOX(vbox), display, 1, 0, 6);
        4:  137:	gtk_label_set_max_width_chars(GTK_LABEL(display), max_len);
        -:  138:
        -:  139:	/* Register custom CSS */
        4:  140:	context = gtk_widget_get_style_context(display);
        4:  141:	gtk_style_context_add_class(context,"rds_display_field");
        -:  142:
        -:  143:
        -:  144:	/* Create the input field with its set button and
        -:  145:	 * an optional checkbox (flag) for the RT field */
        4:  146:	input_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        4:  147:	if(!input_hbox)
    #####:  148:		goto cleanup;
        4:  149:	gtk_box_pack_start(GTK_BOX(vbox), input_hbox, 1, 1, 6);
        -:  150:
        4:  151:	input = gtk_entry_new();
        4:  152:	if(!input)
    #####:  153:		goto cleanup;
        4:  154:	gtk_box_pack_start(GTK_BOX(input_hbox), input, 1, 1, 6);
        4:  155:	gtk_entry_set_max_width_chars(GTK_ENTRY(input), max_len);
        -:  156:
        4:  157:	if(has_flag) {
        1:  158:		flag_check = jmrg_checkbox_init(st, "Flush remote buffer",
        -:  159:						0, 0, 1);
        1:  160:		if(!flag_check)
    #####:  161:			goto cleanup;
        1:  162:		gtk_box_pack_start(GTK_BOX(input_hbox), flag_check, 0, 0, 2);
        -:  163:	}
        -:  164:
        -:  165:	/* Initialize value_map */	
        4:  166:	vmap = (struct value_map*) malloc(sizeof(struct value_map));
        4:  167:	if(!vmap)
    #####:  168:		goto cleanup;
        4:  169:	memset(vmap, 0, sizeof(struct value_map));
        -:  170:
        4:  171:	vmap->st = st;
        4:  172:	vmap->target = display;
        4:  173:	vmap->type = type;
        4:  174:	vmap->entry = input;
        4:  175:	vmap->flag = flag_check;
        -:  176:
        -:  177:	/* Add the set button */
        4:  178:	set_button = jmrg_set_button_init("Set", vmap);
        4:  179:	if(!set_button)
    #####:  180:		goto cleanup;
        4:  181:	gtk_box_pack_start(GTK_BOX(input_hbox), set_button, 0, 0, 6);
        -:  182:
        -:  183:
        -:  184:	/* If it's Dynamic PSN / RT, add the file chooser */
        4:  185:	if(is_dynamic) {
        2:  186:		file_chooser = jmrg_file_chooser_init(vmap);
        2:  187:		if(!file_chooser)
    #####:  188:			goto cleanup;
        2:  189:		gtk_box_pack_start(GTK_BOX(vbox), file_chooser, 1, 1, 6);
        2:  190:		gtk_widget_set_halign(file_chooser, GTK_ALIGN_START);
        2:  191:		gtk_widget_set_sensitive(file_chooser, FALSE);
        2:  192:		vmap->target2 = file_chooser;
        -:  193:	}
        -:  194:
        -:  195:	/* Register polling function and signal handlers */
        4:  196:	vmap->esid = g_timeout_add(200, jmrg_display_field_poll, vmap);
        -:  197:
        4:  198:	g_signal_connect(display, "unrealize", G_CALLBACK(jmrg_free_vmap),
        -:  199:			 vmap);
        -:  200:
        4:  201:	return container;
    #####:  202: cleanup:
    #####:  203:	if(vmap)
    #####:  204:		free(vmap);
    #####:  205:	if(set_button)
    #####:  206:		gtk_widget_destroy(set_button);
    #####:  207:	if(input)
    #####:  208:		gtk_widget_destroy(input);
    #####:  209:	if(input_hbox)
    #####:  210:		gtk_widget_destroy(input_hbox);
    #####:  211:	if(display)
    #####:  212:		gtk_widget_destroy(display);
    #####:  213:	if(vbox)
    #####:  214:		gtk_widget_destroy(vbox);
    #####:  215:	if(container)
    #####:  216:		gtk_widget_destroy(container);
    #####:  217:	return NULL;	
        -:  218:}
        -:  219:

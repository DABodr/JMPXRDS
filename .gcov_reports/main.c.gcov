        -:    0:Source:main.c
        -:    1:/*
        -:    2: * JMPXRDS, an FM MPX signal generator with RDS support on
        -:    3: * top of Jack Audio Connection Kit - Main loop
        -:    4: *
        -:    5: * Copyright (C) 2015 Nick Kossifidis <mickflemm@gmail.com>
        -:    6: *
        -:    7: * This program is free software: you can redistribute it and/or modify
        -:    8: * it under the terms of the GNU General Public License as published by
        -:    9: * the Free Software Foundation, either version 3 of the License, or
        -:   10: * (at your option) any later version.
        -:   11: *
        -:   12: * This program is distributed in the hope that it will be useful,
        -:   13: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15: * GNU General Public License for more details.
        -:   16: *
        -:   17: * You should have received a copy of the GNU General Public License
        -:   18: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19: */
        -:   20:#include "fmmod.h"
        -:   21:#include "utils.h"
        -:   22:#include <stdlib.h>		/* For NULL */
        -:   23:#include <unistd.h>		/* For sleep() */
        -:   24:#include <stdio.h>		/* For printf */
        -:   25:#include <sched.h>		/* For sched_setscheduler etc */
        -:   26:#include <signal.h>		/* For signal handling / sig_atomic_t */
        -:   27:#include <string.h>		/* For memset() */
        -:   28:
        -:   29:#ifdef DEBUG
        -:   30:#include <execinfo.h>		/* For backtrace() etc */
        -:   31:#include <ucontext.h>
        -:   32:#endif
        -:   33:
        -:   34:static volatile sig_atomic_t active;
        -:   35:
        -:   36:static void
        6:   37:signal_handler(int sig, siginfo_t * info,
        -:   38:	       __attribute__((unused)) void *context)
        -:   39:{
        -:   40:#ifdef DEBUG
        -:   41:	void *bt[16] = {0};
        -:   42:	int bt_size = 0;
        -:   43:	char **messages = NULL;
        -:   44:	int i = 0;
        -:   45:	ucontext_t *uc = (ucontext_t *)context;
        -:   46:#endif
        6:   47:	switch (sig) {
    #####:   48:	case SIGPIPE:
    #####:   49:		return;
        2:   50:	case SIGUSR1:
        2:   51:		rtp_server_add_receiver(info->si_value.sival_int);
        2:   52:		break;
        3:   53:	case SIGUSR2:
        3:   54:		rtp_server_remove_receiver(info->si_value.sival_int);
        3:   55:		break;
    #####:   56:	case SIGABRT:
    #####:   57:		utils_err("[MAIN] Got abort at %p \n",
        -:   58:			  info->si_addr);
        -:   59:#ifdef DEBUG
        -:   60:		if(info->si_addr) {
        -:   61:			bt_size = backtrace(bt, 16);
        -:   62:			messages = backtrace_symbols(bt, bt_size);
        -:   63:			utils_trace("Backtrace:\n");
        -:   64:			for(i= 1; i < bt_size; ++i)
        -:   65:				utils_trace("\t%s\n", messages[i]);
        -:   66:		}
        -:   67:#endif
    #####:   68:		utils_shm_unlink_all();
    #####:   69:		raise(SIGKILL);
    #####:   70:		break;
    #####:   71:	case SIGSEGV:
    #####:   72:		utils_err("[MAIN] Got segfault at %p \n",
        -:   73:			  info->si_addr);
        -:   74:#ifdef DEBUG
        -:   75:		if(info->si_addr) {
        -:   76:			bt_size = backtrace(bt, 16);
        -:   77:			messages = backtrace_symbols(bt, bt_size);
        -:   78:			utils_trace("Backtrace:\n");
        -:   79:			for(i= 1; i < bt_size; ++i)
        -:   80:				utils_trace("\t%s\n", messages[i]);
        -:   81:		}
        -:   82:#endif
    #####:   83:		utils_shm_unlink_all();
    #####:   84:		raise(SIGKILL);
    #####:   85:		break;
        1:   86:	default:
        1:   87:		active = 0;
        1:   88:		break;
        -:   89:	}
        -:   90:
        6:   91:	return;
        -:   92:}
        -:   93:
        -:   94:int
        1:   95:main()
        -:   96:{
        1:   97:	int ret = 0;
        -:   98:	struct sched_param sched;
        -:   99:	struct fmmod_instance fmmod_instance;
        -:  100:	struct sigaction sa;
        -:  101:
        1:  102:	memset(&sched, 0, sizeof(struct sched_param));
        1:  103:	memset(&sa, 0, sizeof(struct sigaction));
        -:  104:
        1:  105:	sched_getparam(0, &sched);
        1:  106:	sched.sched_priority = 99;
        1:  107:	if (sched_setscheduler(0, SCHED_FIFO, &sched) != 0)
    #####:  108:		utils_perr("[MAIN] Unable to set real time scheduling:");
        -:  109:
        1:  110:	ret = fmmod_initialize(&fmmod_instance);
        1:  111:	if (ret < 0)
    #####:  112:		exit(ret);
        -:  113:
        1:  114:	active = 1;
        -:  115:
        -:  116:	/* Install a signal handler for graceful exit 
        -:  117:	 * and for handling SIGPIPE */
        1:  118:	sigemptyset(&sa.sa_mask);
        1:  119:	sa.sa_flags = SA_SIGINFO;
        1:  120:	sa.sa_sigaction = signal_handler;
        1:  121:	sigaction(SIGQUIT, &sa, NULL);
        1:  122:	sigaction(SIGTERM, &sa, NULL);
        1:  123:	sigaction(SIGHUP, &sa, NULL);
        1:  124:	sigaction(SIGINT, &sa, NULL);
        1:  125:	sigaction(SIGPIPE, &sa, NULL);
        1:  126:	sigaction(SIGUSR1, &sa, NULL);
        1:  127:	sigaction(SIGUSR2, &sa, NULL);
        1:  128:	sigaction(SIGSEGV, &sa, NULL);
        1:  129:	sigaction(SIGABRT, &sa, NULL);
        -:  130:
        1:  131:	utils_ann("JMPXRDS Started\n");
        -:  132:
        -:  133:	/* Keep running until the transport stops
        -:  134:	 * or in case we are interrupted */
      201:  135:	while (active && fmmod_instance.active)
      200:  136:		sleep(1);
        -:  137:
        1:  138:	if (fmmod_instance.active)
        1:  139:		fmmod_destroy(&fmmod_instance, 0);
        1:  140:	exit(0);
        -:  141:}

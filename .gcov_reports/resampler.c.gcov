        -:    0:Source:resampler.c
        -:    1:/*
        -:    2: * JMPXRDS, an FM MPX signal generator with RDS support on
        -:    3: * top of Jack Audio Connection Kit - Resampler
        -:    4: *
        -:    5: * Copyright (C) 2015 Nick Kossifidis <mickflemm@gmail.com>
        -:    6: *
        -:    7: * This program is free software: you can redistribute it and/or modify
        -:    8: * it under the terms of the GNU General Public License as published by
        -:    9: * the Free Software Foundation, either version 3 of the License, or
        -:   10: * (at your option) any later version.
        -:   11: *
        -:   12: * This program is distributed in the hope that it will be useful,
        -:   13: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15: * GNU General Public License for more details.
        -:   16: *
        -:   17: * You should have received a copy of the GNU General Public License
        -:   18: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19: */
        -:   20:#include "resampler.h"
        -:   21:#include <stdlib.h>		/* For NULL */
        -:   22:#include <string.h>		/* For memset/memcpy */
        -:   23:#include <jack/thread.h>	/* For thread handling through jack */
        -:   24:
        -:   25:
        -:   26:/*********\
        -:   27:* HELPERS *
        -:   28:\*********/
        -:   29:
        -:   30:static void
    18526:   31:resampler_thread_run(struct resampler_thread_data *rstd)
        -:   32:{
    37052:   33:	rstd->result = soxr_process(rstd->resampler, &rstd->in, rstd->inframes,
    18526:   34:				    &rstd->frames_used, &rstd->out, rstd->outframes,
        -:   35:				    &rstd->frames_generated);
    18526:   36:}
        -:   37:
        -:   38:#ifdef JMPXRDS_MT
        -:   39:static void*
        -:   40:resampler_loop(void *arg)
        -:   41:{
        -:   42:	struct resampler_thread_data *rstd = (struct resampler_thread_data*) arg;
        -:   43:
        -:   44:	while((*rstd->active)) {
        -:   45:		pthread_mutex_lock(&rstd->proc_mutex);
        -:   46:		while (pthread_cond_wait(&rstd->proc_trigger, &rstd->proc_mutex) != 0);
        -:   47:
        -:   48:		if(!(*rstd->active))
        -:   49:			break;
        -:   50:
        -:   51:		resampler_thread_run(rstd);
        -:   52:
        -:   53:		pthread_mutex_unlock(&rstd->proc_mutex);
        -:   54:
        -:   55:		/* Let the caller know we are done */
        -:   56:		pthread_mutex_lock(&rstd->done_mutex);
        -:   57:		pthread_cond_signal(&rstd->done_trigger);
        -:   58:		pthread_mutex_unlock(&rstd->done_mutex);
        -:   59:	}
        -:   60:
        -:   61:	return arg;
        -:   62:}
        -:   63:#endif
        -:   64:
        -:   65:static int
        1:   66:resampler_init_upsampler_threads(struct resampler_data *rsmpl)
        -:   67:{
        1:   68:	struct resampler_thread_data *rstd_l = &rsmpl->rstd_l;
        1:   69:	struct resampler_thread_data *rstd_r = &rsmpl->rstd_r;
        -:   70:#ifdef JMPXRDS_MT
        -:   71:	int rtprio = 0;
        -:   72:	int ret = 0;
        -:   73:#endif
        -:   74:
        1:   75:	rstd_l->resampler = rsmpl->audio_upsampler_l;
        1:   76:	rstd_l->active = &rsmpl->active;
        -:   77:
        1:   78:	rstd_r->resampler = rsmpl->audio_upsampler_r;
        1:   79:	rstd_r->active = &rsmpl->active;
        -:   80:
        -:   81:#ifdef JMPXRDS_MT
        -:   82:	pthread_mutex_init(&rstd_l->proc_mutex, NULL);
        -:   83:	pthread_cond_init(&rstd_l->proc_trigger, NULL);
        -:   84:	pthread_mutex_init(&rstd_l->done_mutex, NULL);
        -:   85:	pthread_cond_init(&rstd_l->done_trigger, NULL);
        -:   86:
        -:   87:	rtprio = jack_client_max_real_time_priority(rsmpl->fmmod_client);
        -:   88:	if(rtprio < 0)
        -:   89:		return -1;
        -:   90:
        -:   91:	ret = jack_client_create_thread(rsmpl->fmmod_client, &rstd_l->tid,
        -:   92:					rtprio, 1,
        -:   93:					resampler_loop, (void *) rstd_l);
        -:   94:	if(ret < 0)
        -:   95:		return -1;
        -:   96:#endif
        -:   97:
        1:   98:	return 0;
        -:   99:}
        -:  100:
        -:  101:
        -:  102:/**************\
        -:  103:* ENTRY POINTS *
        -:  104:\**************/
        -:  105:
        -:  106:/*
        -:  107: * Since we oscilate the sound using high frequency signals from the
        -:  108: * main oscilator, we need to upsample the sound to the sample rate of
        -:  109: * the main oscilator and do our processing at that sampling rate. Same
        -:  110: * goes for RDS which operates at a much smaller sampling rate than audio.
        -:  111: * After the processing is done we again need to downsample the result
        -:  112: * (the MPX signal) to the sample rate of the sound card (jack's sample
        -:  113: * rate), so that it can go out. That's the purpose of the resampler
        -:  114: * implemented here.
        -:  115: */
        -:  116:
        -:  117:/* Upsample audio to the main oscilator's sampling rate */
        -:  118:int
     9263:  119:resampler_upsample_audio(struct resampler_data *rsmpl,
        -:  120:			 const float *in_l, const float *in_r,
        -:  121:			 float *out_l, float *out_r,
        -:  122:			 uint32_t inframes, uint32_t outframes)
        -:  123:{
     9263:  124:	struct resampler_thread_data *rstd_l = &rsmpl->rstd_l;
     9263:  125:	struct resampler_thread_data *rstd_r = &rsmpl->rstd_r;
     9263:  126:	size_t frames_generated = 0;
        -:  127:
        -:  128:	/* No need to upsample anything, just copy the buffers.
        -:  129:	 * Note: This is here for debugging mostly */
     9263:  130:	if (rsmpl->audio_upsampler_bypass) {
    #####:  131:		memcpy(out_l, in_l, inframes * sizeof(float));
    #####:  132:		memcpy(out_r, in_r, inframes * sizeof(float));
    #####:  133:		frames_generated = inframes;
    #####:  134:		return frames_generated;
        -:  135:	}
        -:  136:
        -:  137:#ifdef JMPXRDS_MT
        -:  138:	pthread_mutex_lock(&rstd_l->proc_mutex);
        -:  139:	rstd_l->inframes = inframes;
        -:  140:	rstd_l->in = in_l;
        -:  141:	rstd_l->out = out_l;
        -:  142:	rstd_l->outframes = outframes;
        -:  143:	pthread_mutex_unlock(&rstd_l->proc_mutex);
        -:  144:
        -:  145:	rstd_r->inframes = inframes;
        -:  146:	rstd_r->in = in_r;
        -:  147:	rstd_r->out = out_r;
        -:  148:	rstd_r->outframes = outframes;
        -:  149:
        -:  150:	/* Signal the left channel thread to start
        -:  151:	 * processing this chunk */
        -:  152:	pthread_mutex_lock(&rstd_l->proc_mutex);
        -:  153:	pthread_cond_signal(&rstd_l->proc_trigger);
        -:  154:	pthread_mutex_unlock(&rstd_l->proc_mutex);
        -:  155:
        -:  156:	/* Process right channel on current thread */
        -:  157:	resampler_thread_run(rstd_r);
        -:  158:
        -:  159:	/* Wait for the left channel thread to finish */
        -:  160:	while(pthread_cond_wait(&rstd_l->done_trigger, &rstd_l->done_mutex) != 0);
        -:  161:
        -:  162:#else
     9263:  163:	rstd_l->inframes = inframes;
     9263:  164:	rstd_l->in = in_l;
     9263:  165:	rstd_l->out = out_l;
     9263:  166:	rstd_l->outframes = outframes;
        -:  167:
     9263:  168:	resampler_thread_run(rstd_l);
        -:  169:
     9263:  170:	rstd_r->inframes = inframes;
     9263:  171:	rstd_r->in = in_r;
     9263:  172:	rstd_r->out = out_r;
     9263:  173:	rstd_r->outframes = outframes;
        -:  174:
     9263:  175:	resampler_thread_run(rstd_r);
        -:  176:#endif
     9263:  177:	if(rstd_l->result || rstd_r->result)
    #####:  178:		return -1;
        -:  179:	else
     9263:  180:		return rstd_l->frames_generated;
        -:  181:}
        -:  182:
        -:  183:/* Upsample RDS waveform to the main oscilator's sampling rate */
        -:  184:int
     1529:  185:resampler_upsample_rds(const struct resampler_data *rsmpl, const float *in, float *out,
        -:  186:		       uint32_t inframes, uint32_t outframes)
        -:  187:{
        -:  188:	soxr_error_t error;
     1529:  189:	size_t frames_used = 0;
     1529:  190:	size_t frames_generated = 0;
        -:  191:
     1529:  192:	error = soxr_process(rsmpl->rds_upsampler, in, inframes, &frames_used,
        -:  193:			     out, outframes, &frames_generated);
     1529:  194:	if (error)
    #####:  195:		return -1;
        -:  196:	else
     1529:  197:		return frames_generated;
        -:  198:}
        -:  199:
        -:  200:/* Downsample MPX signal to JACK's sample rate */
        -:  201:int
     9263:  202:resampler_downsample_mpx(const struct resampler_data *rsmpl, const float *in, float *out,
        -:  203:			 uint32_t inframes, uint32_t outframes)
        -:  204:{
        -:  205:	soxr_error_t error;
     9263:  206:	size_t frames_used = 0;
     9263:  207:	size_t frames_generated = 0;
        -:  208:
        -:  209:	/* No need to upsample anything, just copy the buffers.
        -:  210:	 * Note: This is here for debugging mostly */
     9263:  211:	if (rsmpl->mpx_downsampler_bypass) {
    #####:  212:		memcpy(out, in, inframes * sizeof(float));
    #####:  213:		frames_generated = inframes;
    #####:  214:		return frames_generated;
        -:  215:	} else {
     9263:  216:		error = soxr_process(rsmpl->mpx_downsampler, in, inframes,
        -:  217:				     &frames_used, out, outframes,
        -:  218:				     &frames_generated);
        -:  219:	}
        -:  220:
     9263:  221:	if (error)
    #####:  222:		return -1;
        -:  223:	else
     9263:  224:		return frames_generated;
        -:  225:}
        -:  226:
        -:  227:/****************\
        -:  228:* INIT / DESTROY *
        -:  229:\****************/
        -:  230:
        -:  231:int
        1:  232:resampler_init(struct resampler_data *rsmpl, uint32_t jack_samplerate,
        -:  233:		jack_client_t *fmmod_client, uint32_t osc_samplerate,
        -:  234:		uint32_t rds_samplerate, uint32_t output_samplerate)
        -:  235:{
        1:  236:	int ret = 0;
        -:  237:	soxr_error_t error;
        -:  238:	soxr_io_spec_t io_spec;
        -:  239:	soxr_runtime_spec_t runtime_spec;
        -:  240:	soxr_quality_spec_t q_spec;
        -:  241:
        1:  242:	if (rsmpl == NULL)
    #####:  243:		return -1;
        -:  244:
        1:  245:	memset(rsmpl, 0, sizeof(struct resampler_data));
        -:  246:
        -:  247:	/* So that RDS encoder can calculate its buffer lengths */
        1:  248:	rsmpl->osc_samplerate = osc_samplerate;
        -:  249:
        1:  250:	rsmpl->fmmod_client = fmmod_client;
        -:  251:
        -:  252:	/* AUDIO UPSAMPLER */
        -:  253:
        1:  254:	if (jack_samplerate == osc_samplerate) {
    #####:  255:		rsmpl->audio_upsampler_bypass = 1;
    #####:  256:		goto audio_upsampler_bypass;
        -:  257:	}
        -:  258:
        -:  259:	/* Initialize upsampler's parameters */
        1:  260:	io_spec = soxr_io_spec(SOXR_FLOAT32_S, SOXR_FLOAT32_S);
        1:  261:	runtime_spec = soxr_runtime_spec(1);
        1:  262:	q_spec = soxr_quality_spec(SOXR_QQ, 0);
        -:  263:
        1:  264:	rsmpl->audio_upsampler_l = soxr_create(jack_samplerate, osc_samplerate, 1,
        -:  265:						&error, &io_spec, &q_spec,
        -:  266:						&runtime_spec);
        1:  267:	if (error) {
    #####:  268:		ret = -2;
    #####:  269:		goto cleanup;
        -:  270:	}
        -:  271:
        1:  272:	rsmpl->audio_upsampler_r = soxr_create(jack_samplerate, osc_samplerate, 1,
        -:  273:						&error, &io_spec, &q_spec,
        -:  274:						&runtime_spec);
        1:  275:	if (error) {
    #####:  276:		ret = -2;
    #####:  277:		goto cleanup;
        -:  278:	}
        -:  279:
        1:  280:	rsmpl->active = 1;
        1:  281:	resampler_init_upsampler_threads(rsmpl);
        -:  282:
        1:  283: audio_upsampler_bypass:
        -:  284:
        -:  285:	/* RDS UPSAMPLER */
        -:  286:
        -:  287:	/* Initialize upsampler's parameters */
        1:  288:	io_spec = soxr_io_spec(SOXR_FLOAT32_I, SOXR_FLOAT32_I);
        1:  289:	runtime_spec = soxr_runtime_spec(1);
        1:  290:	q_spec = soxr_quality_spec(SOXR_QQ, 0);
        1:  291:	rsmpl->rds_upsampler = soxr_create(rds_samplerate, osc_samplerate, 1,
        -:  292:					   &error, &io_spec, &q_spec,
        -:  293:					   &runtime_spec);
        -:  294:
        1:  295:	if (error) {
    #####:  296:		ret = -3;
    #####:  297:		goto cleanup;
        -:  298:	}
        -:  299:
        -:  300:	/* DOWNSAMPLER */
        -:  301:
        1:  302:	if (osc_samplerate == output_samplerate) {
    #####:  303:		rsmpl->mpx_downsampler_bypass = 1;
    #####:  304:		goto cleanup;
        -:  305:	}
        -:  306:
        -:  307:	/* Initialize downsampler's parameters */
        1:  308:	io_spec = soxr_io_spec(SOXR_FLOAT32_I, SOXR_FLOAT32_I);
        1:  309:	runtime_spec = soxr_runtime_spec(1);
        1:  310:	q_spec = soxr_quality_spec(SOXR_HQ, 0);
        1:  311:	q_spec.passband_end = ((double)60000 / (double)output_samplerate) * 2.0L;
        1:  312:	q_spec.stopband_begin = ((double)62500 / (double)output_samplerate) * 2.0L;
        -:  313:
        1:  314:	rsmpl->mpx_downsampler = soxr_create(osc_samplerate, output_samplerate,
        -:  315:					     1, &error, &io_spec, &q_spec,
        -:  316:					     &runtime_spec);
        -:  317:
        1:  318:	if (error) {
    #####:  319:		ret = -4;
    #####:  320:		goto cleanup;
        -:  321:	}
        -:  322:
        1:  323: cleanup:
        1:  324:	if (ret < 0)
    #####:  325:		resampler_destroy(rsmpl);
        -:  326:
        1:  327:	return ret;
        -:  328:}
        -:  329:
        -:  330:void
        1:  331:resampler_destroy(struct resampler_data *rsmpl)
        -:  332:{
        1:  333:	rsmpl->active = 0;
        -:  334:	/* SoXr checks if they are NULL or not */
        1:  335:	soxr_delete(rsmpl->audio_upsampler_l);
        1:  336:	soxr_delete(rsmpl->audio_upsampler_r);
        1:  337:	soxr_delete(rsmpl->rds_upsampler);
        1:  338:	soxr_delete(rsmpl->mpx_downsampler);
        1:  339:}

        -:    0:Source:rtp_tool.c
        -:    1:/*
        -:    2: * JMPXRDS, an FM MPX signal generator with RDS support on
        -:    3: * top of Jack Audio Connection Kit - RTP server runtime configuration tool
        -:    4: *
        -:    5: * Copyright (C) 2016 Nick Kossifidis <mickflemm@gmail.com>
        -:    6: *
        -:    7: * This program is free software: you can redistribute it and/or modify
        -:    8: * it under the terms of the GNU General Public License as published by
        -:    9: * the Free Software Foundation, either version 3 of the License, or
        -:   10: * (at your option) any later version.
        -:   11: *
        -:   12: * This program is distributed in the hope that it will be useful,
        -:   13: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15: * GNU General Public License for more details.
        -:   16: *
        -:   17: * You should have received a copy of the GNU General Public License
        -:   18: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19: */
        -:   20:
        -:   21:#include "utils.h"
        -:   22:#include "rtp_server.h"
        -:   23:#include <signal.h>		/* For sigqueue etc */
        -:   24:#include <arpa/inet.h>		/* For inet_addr etc */
        -:   25:#include <unistd.h>		/* For getopt() */
        -:   26:
        -:   27:static void
        1:   28:usage(char *name)
        -:   29:{
        1:   30:	utils_ann("RTP Server configuration tool for JMPXRDS\n");
        1:   31:	utils_info("Usage: %s -g or [<parameter> <value>] pairs\n", name);
        1:   32:	utils_info("\nParameters:\n"
        -:   33:		"\t-g\t\tGet current status\n"
        -:   34:		"\t-a   <string>\tAdd an IP address to the list of receivers\n"
        -:   35:		"\t-r   <string>\tRemove an IP address from the list of receivers\n");
        1:   36:}
        -:   37:
        -:   38:int
        5:   39:main(int argc, char *argv[])
        -:   40:{
        -:   41:	union sigval value;
        5:   42:	struct shm_mapping *shmem = NULL;
        5:   43:	const struct rtp_server_control *ctl = NULL;
        5:   44:	struct in_addr ipv4addr = { 0 };
        5:   45:	int opt = 0;
        5:   46:	int ret = 0;
        5:   47:	int pid = 0;
        5:   48:	int i = 0;
        -:   49:
        5:   50:	shmem = utils_shm_attach(RTP_SRV_SHM_NAME,
        -:   51:				 sizeof(struct rtp_server_control));
        5:   52:	if (!shmem) {
    #####:   53:		utils_perr("Unable to communicate with the RTP server");
    #####:   54:		return -1;
        -:   55:	}
        5:   56:	ctl = (struct rtp_server_control*) shmem->mem;
        5:   57:	pid = ctl->pid;
        -:   58:
        9:   59:	while ((opt = getopt(argc, argv, "ga:r:")) != -1)
        4:   60:		switch (opt) {
        1:   61:		case 'g':
        1:   62:			utils_info("RTP bytes sent: %" PRIu64 "\n",
        -:   63:			       ctl->rtp_bytes_sent);
        1:   64:			utils_info("RTCP bytes sent: %" PRIu64 "\n",
        -:   65:			       ctl->rtcp_bytes_sent);
        1:   66:			utils_info("List of receivers:\n");
       1*:   67:			for (i = 0; i < ctl->num_receivers; i++) {
    #####:   68:				ipv4addr.s_addr = ctl->receivers[i];
    #####:   69:				utils_info("\t%s\n", inet_ntoa(ipv4addr));
        -:   70:			}
        1:   71:			break;
        1:   72:		case 'a':
        1:   73:			ret = inet_aton(optarg, &ipv4addr);
        1:   74:			if (!ret) {
    #####:   75:				utils_err("Invalid IP address !\n");
    #####:   76:				break;
        -:   77:			}
        1:   78:			value.sival_int = ipv4addr.s_addr;
        1:   79:			if (sigqueue(pid, SIGUSR1, value) != 0)
    #####:   80:				utils_perr("Couldn't send signal, sigqueue()");
        1:   81:			break;
        2:   82:		case 'r':
        2:   83:			ret = inet_aton(optarg, &ipv4addr);
        2:   84:			if (!ret) {
    #####:   85:				utils_err("Invalid IP address !\n");
    #####:   86:				break;
        -:   87:			}
        2:   88:			value.sival_int = ipv4addr.s_addr;
        2:   89:			if (sigqueue(pid, SIGUSR2, value) != 0)
    #####:   90:				utils_perr("Couldn't send signal, sigqueue()");
        2:   91:			break;
    #####:   92:		default:
    #####:   93:			usage(argv[0]);
    #####:   94:			utils_shm_destroy(shmem, 0);
    #####:   95:			return -1;
        -:   96:		}
        -:   97:
        5:   98:	if (argc < 2 || (argc > 1 && optind == 1)) {
        1:   99:		usage(argv[0]);
        1:  100:		ret = -1;
        -:  101:	}
        -:  102:
        5:  103:	utils_shm_destroy(shmem, 0);
        5:  104:	return ret;
        -:  105:}

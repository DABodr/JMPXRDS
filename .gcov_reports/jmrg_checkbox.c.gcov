        -:    0:Source:gui/jmrg_checkbox.c
        -:    1:#include <stdlib.h>	/* For malloc() / free() */
        -:    2:#include <string.h>	/* For memset() */
        -:    3:#include "jmpxrds_gui.h"
        -:    4:
        -:    5:/******************\
        -:    6:* POLLING FUNCTION *
        -:    7:\******************/
        -:    8:
        -:    9:static gboolean
     3976:   10:jmrg_checkbox_poll(gpointer data)
        -:   11:{
     3976:   12:	struct value_map *vmap = (struct value_map*) data;
     3976:   13:	struct rds_encoder_state *st = vmap->st;
     3976:   14:	uint8_t tmp = 0;
     3976:   15:	uint8_t active = 0;
        -:   16:
    3976*:   17:	if(!GTK_IS_TOGGLE_BUTTON(vmap->target))
    #####:   18:		return FALSE;
        -:   19:
     3976:   20:	if(!gtk_widget_is_visible(vmap->target))
     1246:   21:		return TRUE;
        -:   22:
     2730:   23:	if(gtk_widget_has_focus(vmap->target))
       63:   24:		return TRUE;
        -:   25:
     2667:   26:	tmp = vmap->getter(st);
     2667:   27:	tmp &= vmap->mask;
        -:   28:
     2667:   29:	active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(vmap->target));
        -:   30:
     2667:   31:	if((!tmp && !active) || (tmp && active))
     2664:   32:		return TRUE;
        -:   33:
        3:   34:	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(vmap->target),
        -:   35:				     (tmp != 0) ? TRUE : FALSE);
        3:   36:	return TRUE;
        -:   37:}
        -:   38:
        -:   39:
        -:   40:/*****************\
        -:   41:* SIGNAL HANDLERS *
        -:   42:\*****************/
        -:   43:
        -:   44:static void
       21:   45:jmrg_checkbox_toggled(GtkToggleButton *tbutton, gpointer data)
        -:   46:{
       21:   47:	struct value_map *vmap = (struct value_map*) data;
       21:   48:	struct rds_encoder_state *st = vmap->st;
       21:   49:	uint8_t tmp = 0;
       21:   50:	uint8_t active = 0;
        -:   51:
       21:   52:	tmp = vmap->getter(st);
        -:   53:
       21:   54:	active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(tbutton));
        -:   55:
       21:   56:	if((!(tmp & vmap->mask) && !active) || ((tmp & vmap->mask) && active))
        3:   57:		return;
        -:   58:
       18:   59:	if(active)
        8:   60:		vmap->setter(st, tmp | vmap->mask);
        -:   61:	else
       10:   62:		vmap->setter(st, tmp & ~(vmap->mask));
        -:   63:
       18:   64:	return;
        -:   65:}
        -:   66:
        -:   67:
        -:   68:/*************\
        -:   69:* ENTRY POINT *
        -:   70:\*************/
        -:   71:
        -:   72:GtkWidget*
        8:   73:jmrg_checkbox_init(struct rds_encoder_state *st, const char* label, int type,
        -:   74:		   int mask, int ignore)
        -:   75:{
        8:   76:	GtkWidget *checkbox = NULL;
        8:   77:	struct value_map *vmap = NULL;
        -:   78:
        -:   79:	/* Initialize checkbox */
        8:   80:	checkbox = gtk_check_button_new_with_label(label);
        8:   81:	if(!checkbox)
    #####:   82:		goto cleanup;
        -:   83:
        -:   84:	/* Checkbox is managed from someone else (used for RT A/B flag) */
        8:   85:	if(ignore)
        1:   86:		return checkbox;
        -:   87:
        -:   88:
        -:   89:	/* Initialize value_map */
        7:   90:	vmap = (struct value_map*) malloc(sizeof(struct value_map));
        7:   91:	if(!vmap)
    #####:   92:		goto cleanup;
        7:   93:	memset(vmap, 0, sizeof(struct value_map));
        -:   94:
        7:   95:	vmap->target = checkbox;
        7:   96:	vmap->st = st;
        7:   97:	vmap->mask = mask;
        -:   98:
        7:   99:	switch(type) {
        1:  100:	case RDS_FIELD_TA:
        1:  101:		vmap->getter = rds_get_ta;
        1:  102:		vmap->setter = rds_set_ta;
        1:  103:		break;
        1:  104:	case RDS_FIELD_TP:
        1:  105:		vmap->getter = rds_get_tp;
        1:  106:		vmap->setter = rds_set_tp;
        1:  107:		break;
        1:  108:	case RDS_FIELD_MS:
        1:  109:		vmap->getter = rds_get_ms;
        1:  110:		vmap->setter = rds_set_ms;
        1:  111:		break;
        4:  112:	case RDS_FIELD_DI:
        4:  113:		vmap->getter = rds_get_di;
        4:  114:		vmap->setter = rds_set_di;
        4:  115:		break;
    #####:  116:	default:
    #####:  117:		goto cleanup;
        -:  118:	}
        -:  119:
        -:  120:
        -:  121:	/* Register polling function and signal handlers */
        7:  122:	vmap->esid = g_timeout_add(200, jmrg_checkbox_poll, vmap);
        -:  123:
        7:  124:	g_signal_connect(checkbox, "toggled", G_CALLBACK(jmrg_checkbox_toggled),
        -:  125:			 vmap);
        -:  126:
        7:  127:	g_signal_connect(checkbox, "unrealize", G_CALLBACK(jmrg_free_vmap),
        -:  128:			 vmap);
        -:  129:
        7:  130:	return checkbox;
    #####:  131: cleanup:
    #####:  132:	if(vmap)
    #####:  133:		free(vmap);
    #####:  134:	if(checkbox)
    #####:  135:		gtk_widget_destroy(checkbox);
    #####:  136:	return NULL;
        -:  137:}

        -:    0:Source:gui/jmrg_acentry.c
        -:    1:#include <stdlib.h>	/* For malloc() / free() */
        -:    2:#include <string.h>	/* For strcmp() / memset() */
        -:    3:#include "jmpxrds_gui.h"
        -:    4:#include "rds_codes.h"
        -:    5:
        -:    6:/******************\
        -:    7:* POLLING FUNCTION *
        -:    8:\******************/
        -:    9:
        -:   10:static gboolean
     1136:   11:jmrg_acentry_poll(gpointer data)
        -:   12:{
     1136:   13:	struct value_map *vmap = (struct value_map*) data;
     1136:   14:	struct rds_encoder_state *st = vmap->st;
     1136:   15:	int tmp = 0;
     1136:   16:	int tmp2 = 0;
     1136:   17:	const char* name = NULL;
        -:   18:
    1136*:   19:	if(!GTK_IS_ENTRY(vmap->target))
    #####:   20:		return FALSE;
        -:   21:
     1136:   22:	if(!gtk_widget_is_visible(vmap->target))
      356:   23:		return TRUE;
        -:   24:
      780:   25:	if(gtk_widget_has_focus(vmap->target))
       25:   26:		return TRUE;
        -:   27:
      755:   28:	switch(vmap->type) {
      380:   29:	case RDS_FIELD_ECC:
      380:   30:		tmp = rds_get_ecc(st);
      380:   31:		tmp2 = rds_get_pi(st);
      380:   32:		tmp2 = (tmp2 >> 12);
      380:   33:		tmp = rds_codes_get_ctry_idx_from_ctry_codes(tmp2, tmp); 
      380:   34:		name = rds_codes_get_ctry_name(tmp);
      380:   35:		break;
      375:   36:	case RDS_FIELD_LIC:
      375:   37:		tmp = rds_get_lic(st);
      375:   38:		tmp = rds_codes_get_lang_idx_from_lic(tmp);
      375:   39:		name = rds_codes_get_lang_name(tmp);
      375:   40:		break;
    #####:   41:	default:
    #####:   42:		return FALSE;
        -:   43:	}
        -:   44:
      755:   45:	if(name)
      755:   46:		gtk_entry_set_text(GTK_ENTRY(vmap->target), name);
        -:   47:
      755:   48:	return TRUE;
        -:   49:}
        -:   50:
        -:   51:
        -:   52:/*****************\
        -:   53:* SIGNAL HANDLERS *
        -:   54:\*****************/
        -:   55:
        -:   56:static gboolean
        2:   57:jmrg_acentry_match(__attribute__((unused)) GtkEntryCompletion *widget,
        -:   58:		   GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
        -:   59:{
        2:   60:	struct value_map *vmap = (struct value_map*) data;
        2:   61:	GValue value = {0};
        -:   62:
        2:   63:	gtk_tree_model_get_value(model, iter, 1, &value);
        2:   64:	vmap->acentry_match_idx = g_value_get_int(&value);
        -:   65:
        2:   66:	g_value_unset(&value);
        -:   67:
        -:   68:	/* Fallback to the default handler */
        2:   69:	return FALSE;
        -:   70:}
        -:   71:
        -:   72:
        -:   73:/*************\
        -:   74:* ENTRY POINT *
        -:   75:\*************/
        -:   76:
        -:   77:GtkWidget*
        2:   78:jmrg_acentry_init(struct rds_encoder_state *st, const char* label, int type)
        -:   79:{
        2:   80:	GtkWidget *container = NULL;
        2:   81:	GtkWidget *hbox = NULL;
        2:   82:	GtkWidget *acentry = NULL;
        2:   83:	GtkEntryCompletion *entry_completion = NULL;
        2:   84:	GtkWidget *set_button = NULL;
        2:   85:	GtkListStore *model = NULL;
        2:   86:	GtkTreeIter iter = {0};
        2:   87:	struct value_map *vmap = NULL;
        2:   88:	const char *name = NULL;
        2:   89:	const char *prev_name = NULL;
        2:   90:	int i = 0;
        -:   91:
        -:   92:	/* Use a frame to also have a label there
        -:   93:	 * for free */
        2:   94:	container = gtk_frame_new(label);
        2:   95:	if(!container)
    #####:   96:		goto cleanup;
        2:   97:	gtk_frame_set_label_align(GTK_FRAME(container), 0.05, 0.6);
        2:   98:	gtk_frame_set_shadow_type(GTK_FRAME(container),
        -:   99:				  GTK_SHADOW_ETCHED_IN);
        -:  100:
        -:  101:
        -:  102:	/* Use a box to have better control */
        2:  103:	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        2:  104:	if(!hbox)
    #####:  105:		goto cleanup;
        2:  106:	gtk_container_add(GTK_CONTAINER(container), hbox);
        -:  107:
        -:  108:
        -:  109:	/* Initialize an entry with auto-completion */	
        2:  110:	acentry = gtk_entry_new();
        2:  111:	if(!acentry)
    #####:  112:		goto cleanup;
        2:  113:	gtk_box_pack_start(GTK_BOX(hbox), acentry, 1, 1, 6);
        -:  114:
        2:  115:	entry_completion = gtk_entry_completion_new();
        2:  116:	if(!entry_completion)
    #####:  117:		goto cleanup;
        2:  118:	gtk_entry_set_completion(GTK_ENTRY(acentry), entry_completion);
        2:  119:	gtk_entry_completion_set_text_column(entry_completion, 0);
        -:  120:
        -:  121:
        -:  122:	/* Initialize auto-completion model */
        2:  123:	model = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_INT);
        2:  124:	if(!model)
    #####:  125:		goto cleanup;
        -:  126:
        2:  127:	switch(type) {
        1:  128:	case RDS_FIELD_ECC:
        1:  129:		name = rds_codes_get_ctry_name(i);
      223:  130:		while(name[0] != '\0') {
      222:  131:			gtk_list_store_append(model, &iter);
      222:  132:			gtk_list_store_set(model, &iter, 0, name, 1, i, -1);
      222:  133:			prev_name = name;
        -:  134:			/* Some countries have multiple country codes
        -:  135:			 * and appear more than once, make sure we don't
        -:  136:			 * add their names again */
      462:  137:			while(!strcmp(prev_name, name)) {
      240:  138:				i++;
      240:  139:				name = rds_codes_get_ctry_name(i);
        -:  140:			}
        -:  141:		}
        1:  142:		break;
        1:  143:	case RDS_FIELD_LIC:
        1:  144:		name = rds_codes_get_lang_name(i);
      105:  145:		while(name[0] != '\0') {
      104:  146:			gtk_list_store_append(model, &iter);
      104:  147:			gtk_list_store_set(model, &iter, 0, name, 1, i, -1);
      104:  148:			name = rds_codes_get_lang_name(++i);
        -:  149:		}
        1:  150:		break;
    #####:  151:	default:
    #####:  152:		return NULL;
        -:  153:	}
        2:  154:	gtk_entry_completion_set_model(entry_completion, GTK_TREE_MODEL(model));
        -:  155:
        -:  156:
        -:  157:	/* Initialize value_map */
        2:  158:	vmap = (struct value_map*) malloc(sizeof(struct value_map));
        2:  159:	if(!vmap)
    #####:  160:		goto cleanup;
        2:  161:	memset(vmap, 0, sizeof(struct value_map));
        -:  162:
        2:  163:	vmap->target = acentry;
        2:  164:	vmap->st = st;
        2:  165:	vmap->type = type;
        2:  166:	vmap->acentry_match_idx = -1;
        -:  167:
        -:  168:
        -:  169:	/* Add the set button */
        2:  170:	set_button = jmrg_set_button_init("Set", vmap);
        2:  171:	if(!set_button)
    #####:  172:		goto cleanup;
        2:  173:	gtk_box_pack_start(GTK_BOX(hbox), set_button, 1, 1, 6);
        -:  174:
        -:  175:
        -:  176:	/* Register polling function and signal handlers */
        2:  177:	vmap->esid = g_timeout_add(200, jmrg_acentry_poll, vmap);
        -:  178:
        2:  179:	g_signal_connect(G_OBJECT(entry_completion), "match-selected",
        -:  180:			 G_CALLBACK(jmrg_acentry_match), vmap);
        -:  181:
        2:  182:	g_signal_connect(acentry, "unrealize", G_CALLBACK(jmrg_free_vmap),
        -:  183:			 vmap);
        -:  184:
        2:  185:	return container;
    #####:  186: cleanup:
    #####:  187:	if(vmap)
    #####:  188:		free(vmap);
    #####:  189:	if(model)
    #####:  190:		g_object_unref(model);
    #####:  191:	if(entry_completion)
    #####:  192:		g_object_unref(entry_completion);
    #####:  193:	if(acentry)
    #####:  194:		gtk_widget_destroy(acentry);
    #####:  195:	if(hbox)
    #####:  196:		gtk_widget_destroy(hbox);
    #####:  197:	if(container)
    #####:  198:		gtk_widget_destroy(container);
    #####:  199:	return NULL;
        -:  200:}

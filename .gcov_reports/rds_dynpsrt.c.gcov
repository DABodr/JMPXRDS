        -:    0:Source:rds_dynpsrt.c
        -:    1:/*
        -:    2: * JMPXRDS, an FM MPX signal generator with RDS support on
        -:    3: * top of Jack Audio Connection Kit - RDS Dynamic PSN / RT handling
        -:    4: *
        -:    5: * Copyright (C) 2015 Nick Kossifidis <mickflemm@gmail.com>
        -:    6: *
        -:    7: * This program is free software: you can redistribute it and/or modify
        -:    8: * it under the terms of the GNU General Public License as published by
        -:    9: * the Free Software Foundation, either version 3 of the License, or
        -:   10: * (at your option) any later version.
        -:   11: *
        -:   12: * This program is distributed in the hope that it will be useful,
        -:   13: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15: * GNU General Public License for more details.
        -:   16: *
        -:   17: * You should have received a copy of the GNU General Public License
        -:   18: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19: */
        -:   20:#include "rds_encoder.h"
        -:   21:#include "utils.h"
        -:   22:#include <stdio.h>		/* For fopen(), FILE etc */
        -:   23:#include <string.h>		/* For memset/strnlen/strncpy etc */
        -:   24:#include <unistd.h>		/* For read() / close() */
        -:   25:#include <pthread.h>		/* For pthread support */
        -:   26:#include <time.h>		/* For clock_gettime() */
        -:   27:#include <ctype.h>		/* For isspace() */
        -:   28:#include <errno.h>		/* For errno */
        -:   29:#include <stdlib.h>		/* For free() */
        -:   30:
        -:   31:/*********\
        -:   32:* HELPERS *
        -:   33:\*********/
        -:   34:
        -:   35:static void
       34:   36:rds_dynpsrt_cond_sleep(pthread_cond_t *trig, pthread_mutex_t *mutex, int delay_secs)
        -:   37:{
       34:   38:	struct timespec ts = {0};
       34:   39:	clock_gettime(CLOCK_REALTIME, &ts);
       34:   40:	ts.tv_sec += delay_secs;
       34:   41:	pthread_mutex_lock(mutex);
       39:   42:	while(!pthread_cond_timedwait(trig, mutex, &ts));
       34:   43:	pthread_mutex_unlock(mutex);
       34:   44:}
------------------
rds_dynpsrt_cond_sleep:
       29:   36:rds_dynpsrt_cond_sleep(pthread_cond_t *trig, pthread_mutex_t *mutex, int delay_secs)
        -:   37:{
       29:   38:	struct timespec ts = {0};
       29:   39:	clock_gettime(CLOCK_REALTIME, &ts);
       29:   40:	ts.tv_sec += delay_secs;
       29:   41:	pthread_mutex_lock(mutex);
       32:   42:	while(!pthread_cond_timedwait(trig, mutex, &ts));
       29:   43:	pthread_mutex_unlock(mutex);
       29:   44:}
------------------
rds_dynpsrt_cond_sleep:
        5:   36:rds_dynpsrt_cond_sleep(pthread_cond_t *trig, pthread_mutex_t *mutex, int delay_secs)
        -:   37:{
        5:   38:	struct timespec ts = {0};
        5:   39:	clock_gettime(CLOCK_REALTIME, &ts);
        5:   40:	ts.tv_sec += delay_secs;
        5:   41:	pthread_mutex_lock(mutex);
        7:   42:	while(!pthread_cond_timedwait(trig, mutex, &ts));
        5:   43:	pthread_mutex_unlock(mutex);
        5:   44:}
------------------
        -:   45:
        -:   46:static int
       4*:   47:rds_string_sanitize(char *string, size_t max_len)
        -:   48:{
        -:   49:	/* TODO: Maybe clean up symbols, dots etc */
       4*:   50:	int len = strnlen(string, max_len);
       4*:   51:	int i = 1;
       4*:   52:	int off = 0;
        -:   53:
        -:   54:	/* Sanity check */
       4*:   55:	if(len <= 0)
    #####:   56:		return -1;
        -:   57:
        -:   58:	/* Trim trailing white space */
       8*:   59:	while(isspace(string[len - i]) && i <= len) {
       4*:   60:		string[len - i] = '\0';
       4*:   61:		i++;
        -:   62:	}
        -:   63:
        -:   64:	/* Only got whitespace ? */
       4*:   65:	if(i == len)
    #####:   66:		return -2;
        -:   67:
        -:   68:	/* Trim leading white space */
       7*:   69:	while(isspace(string[off]) && off < len - 1)
       3*:   70:		off++;
        -:   71:
        -:   72:	/* Move the string in place */
       4*:   73:	if(off > 0) {
       3*:   74:		memmove(string, string + off, len - off);
        -:   75:		/* In case we didn't have any trailing white space
        -:   76:		 * add a null terminator. */
       3*:   77:		if(!isspace(string[len - 1]))
       3*:   78:			string[len - off - 1] = '\0';
        -:   79:	}
        -:   80:
        -:   81:	/* Update len */
       4*:   82:	len = strnlen(string, max_len);
       4*:   83:	return len;
        -:   84:}
------------------
rds_string_sanitize:
        4:   47:rds_string_sanitize(char *string, size_t max_len)
        -:   48:{
        -:   49:	/* TODO: Maybe clean up symbols, dots etc */
        4:   50:	int len = strnlen(string, max_len);
        4:   51:	int i = 1;
        4:   52:	int off = 0;
        -:   53:
        -:   54:	/* Sanity check */
        4:   55:	if(len <= 0)
    #####:   56:		return -1;
        -:   57:
        -:   58:	/* Trim trailing white space */
        8:   59:	while(isspace(string[len - i]) && i <= len) {
        4:   60:		string[len - i] = '\0';
        4:   61:		i++;
        -:   62:	}
        -:   63:
        -:   64:	/* Only got whitespace ? */
        4:   65:	if(i == len)
    #####:   66:		return -2;
        -:   67:
        -:   68:	/* Trim leading white space */
        7:   69:	while(isspace(string[off]) && off < len - 1)
        3:   70:		off++;
        -:   71:
        -:   72:	/* Move the string in place */
        4:   73:	if(off > 0) {
        3:   74:		memmove(string, string + off, len - off);
        -:   75:		/* In case we didn't have any trailing white space
        -:   76:		 * add a null terminator. */
        3:   77:		if(!isspace(string[len - 1]))
        3:   78:			string[len - off - 1] = '\0';
        -:   79:	}
        -:   80:
        -:   81:	/* Update len */
        4:   82:	len = strnlen(string, max_len);
        4:   83:	return len;
        -:   84:}
------------------
rds_string_sanitize:
    #####:   47:rds_string_sanitize(char *string, size_t max_len)
        -:   48:{
        -:   49:	/* TODO: Maybe clean up symbols, dots etc */
    #####:   50:	int len = strnlen(string, max_len);
    #####:   51:	int i = 1;
    #####:   52:	int off = 0;
        -:   53:
        -:   54:	/* Sanity check */
    #####:   55:	if(len <= 0)
    #####:   56:		return -1;
        -:   57:
        -:   58:	/* Trim trailing white space */
    #####:   59:	while(isspace(string[len - i]) && i <= len) {
    #####:   60:		string[len - i] = '\0';
    #####:   61:		i++;
        -:   62:	}
        -:   63:
        -:   64:	/* Only got whitespace ? */
    #####:   65:	if(i == len)
    #####:   66:		return -2;
        -:   67:
        -:   68:	/* Trim leading white space */
    #####:   69:	while(isspace(string[off]) && off < len - 1)
    #####:   70:		off++;
        -:   71:
        -:   72:	/* Move the string in place */
    #####:   73:	if(off > 0) {
    #####:   74:		memmove(string, string + off, len - off);
        -:   75:		/* In case we didn't have any trailing white space
        -:   76:		 * add a null terminator. */
    #####:   77:		if(!isspace(string[len - 1]))
    #####:   78:			string[len - off - 1] = '\0';
        -:   79:	}
        -:   80:
        -:   81:	/* Update len */
    #####:   82:	len = strnlen(string, max_len);
    #####:   83:	return len;
        -:   84:}
------------------
        -:   85:
        -:   86:/*************\
        -:   87:* DYNAMIC PSN *
        -:   88:\*************/
        -:   89:
        -:   90:/*
        -:   91: * Note: Dynamic PSN is highly discouraged and RDS forum has issued various
        -:   92: * statements against it. I've put it here since many stations use it and I
        -:   93: * got a request from radio Best 94.7 in Heraklion for it. This operation will
        -:   94: * switch the station's name every DYNPS_DELAY_SECS so that the PSN field on
        -:   95: * car / old radios presents a scrolling text. The station's name (fixed_ps)
        -:   96: * will be shown each time the dynamic PSN text has been fully "scrolled".
        -:   97: * There are various dynamic PSN modes available out there, here I've implemented
        -:   98: * the "scroll by 8 characters" mode since it's the most reliable and takes fewer
        -:   99: * time to scroll the full text.
        -:  100: */
        -:  101:
        -:  102:static void*
        3:  103:rds_dynps_consumer_thread(void *arg)
        -:  104:{
        3:  105:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        3:  106:	char segment[RDS_PS_LENGTH] = {0};
        3:  107:	int segment_len = 0;
        3:  108:	int off = 0;
        3:  109:	int ret = 0;
        -:  110:
       24:  111:	while(dps->active) {
       21:  112:		pthread_mutex_lock(&dps->dynps_proc_mutex);
       21:  113:		if(dps->string_len) {
       9*:  114:			if(dps->remaining_len == 0) {
       1*:  115:				ret = rds_set_ps(dps->st, dps->fixed_ps);
       1*:  116:				utils_dbg("[DYNPS] %s, status: %i\n",dps->fixed_ps, ret);
       1*:  117:				dps->remaining_len = dps->string_len;
       1*:  118:				pthread_mutex_unlock(&dps->dynps_proc_mutex);
       1*:  119:				continue;
        -:  120:			}
        -:  121:
       8*:  122:			off = dps->string_len - dps->remaining_len;
       8*:  123:			segment_len = (dps->remaining_len >= RDS_PS_LENGTH) ?
        -:  124:				      RDS_PS_LENGTH : dps->remaining_len;
       8*:  125:			memset(segment, 0, RDS_PS_LENGTH);
       8*:  126:			memcpy(segment, dps->string + off, segment_len);
        -:  127:
       8*:  128:			ret = rds_set_ps(dps->st, segment);
       8*:  129:			utils_dbg("[DYNPS] %s, status: %i\n",segment, ret);
        -:  130:
       8*:  131:			if(dps->remaining_len >= RDS_PS_LENGTH)
       7*:  132:				dps->remaining_len -= RDS_PS_LENGTH;
        -:  133:			else
       1*:  134:				dps->remaining_len = 0;
        -:  135:		}
       20:  136:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
       20:  137:		rds_dynpsrt_cond_sleep(&dps->sleep_trig, &dps->sleep_mutex,
        -:  138:				       DYNPS_DELAY_SECS);
        -:  139:	}
        -:  140:
        3:  141:	utils_dbg("[DYNPS] Consumer terminated\n");
        3:  142:	return arg;
        -:  143:}
------------------
rds_dynps_consumer_thread:
        2:  103:rds_dynps_consumer_thread(void *arg)
        -:  104:{
        2:  105:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        2:  106:	char segment[RDS_PS_LENGTH] = {0};
        2:  107:	int segment_len = 0;
        2:  108:	int off = 0;
        2:  109:	int ret = 0;
        -:  110:
       21:  111:	while(dps->active) {
       19:  112:		pthread_mutex_lock(&dps->dynps_proc_mutex);
       19:  113:		if(dps->string_len) {
        9:  114:			if(dps->remaining_len == 0) {
        1:  115:				ret = rds_set_ps(dps->st, dps->fixed_ps);
        1:  116:				utils_dbg("[DYNPS] %s, status: %i\n",dps->fixed_ps, ret);
        1:  117:				dps->remaining_len = dps->string_len;
        1:  118:				pthread_mutex_unlock(&dps->dynps_proc_mutex);
        1:  119:				continue;
        -:  120:			}
        -:  121:
        8:  122:			off = dps->string_len - dps->remaining_len;
        8:  123:			segment_len = (dps->remaining_len >= RDS_PS_LENGTH) ?
        -:  124:				      RDS_PS_LENGTH : dps->remaining_len;
        8:  125:			memset(segment, 0, RDS_PS_LENGTH);
        8:  126:			memcpy(segment, dps->string + off, segment_len);
        -:  127:
        8:  128:			ret = rds_set_ps(dps->st, segment);
        8:  129:			utils_dbg("[DYNPS] %s, status: %i\n",segment, ret);
        -:  130:
        8:  131:			if(dps->remaining_len >= RDS_PS_LENGTH)
        7:  132:				dps->remaining_len -= RDS_PS_LENGTH;
        -:  133:			else
        1:  134:				dps->remaining_len = 0;
        -:  135:		}
       18:  136:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
       18:  137:		rds_dynpsrt_cond_sleep(&dps->sleep_trig, &dps->sleep_mutex,
        -:  138:				       DYNPS_DELAY_SECS);
        -:  139:	}
        -:  140:
        2:  141:	utils_dbg("[DYNPS] Consumer terminated\n");
        2:  142:	return arg;
        -:  143:}
------------------
rds_dynps_consumer_thread:
        1:  103:rds_dynps_consumer_thread(void *arg)
        -:  104:{
        1:  105:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        1:  106:	char segment[RDS_PS_LENGTH] = {0};
        1:  107:	int segment_len = 0;
        1:  108:	int off = 0;
        1:  109:	int ret = 0;
        -:  110:
        3:  111:	while(dps->active) {
        2:  112:		pthread_mutex_lock(&dps->dynps_proc_mutex);
        2:  113:		if(dps->string_len) {
    #####:  114:			if(dps->remaining_len == 0) {
    #####:  115:				ret = rds_set_ps(dps->st, dps->fixed_ps);
    #####:  116:				utils_dbg("[DYNPS] %s, status: %i\n",dps->fixed_ps, ret);
    #####:  117:				dps->remaining_len = dps->string_len;
    #####:  118:				pthread_mutex_unlock(&dps->dynps_proc_mutex);
    #####:  119:				continue;
        -:  120:			}
        -:  121:
    #####:  122:			off = dps->string_len - dps->remaining_len;
    #####:  123:			segment_len = (dps->remaining_len >= RDS_PS_LENGTH) ?
        -:  124:				      RDS_PS_LENGTH : dps->remaining_len;
    #####:  125:			memset(segment, 0, RDS_PS_LENGTH);
    #####:  126:			memcpy(segment, dps->string + off, segment_len);
        -:  127:
    #####:  128:			ret = rds_set_ps(dps->st, segment);
    #####:  129:			utils_dbg("[DYNPS] %s, status: %i\n",segment, ret);
        -:  130:
    #####:  131:			if(dps->remaining_len >= RDS_PS_LENGTH)
    #####:  132:				dps->remaining_len -= RDS_PS_LENGTH;
        -:  133:			else
    #####:  134:				dps->remaining_len = 0;
        -:  135:		}
        2:  136:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
        2:  137:		rds_dynpsrt_cond_sleep(&dps->sleep_trig, &dps->sleep_mutex,
        -:  138:				       DYNPS_DELAY_SECS);
        -:  139:	}
        -:  140:
        1:  141:	utils_dbg("[DYNPS] Consumer terminated\n");
        1:  142:	return arg;
        -:  143:}
------------------
        -:  144:
        -:  145:static void*
        3:  146:rds_dynps_filemon_thread(void *arg)
        -:  147:{
        3:  148:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        3:  149:	const struct inotify_event *event = (struct inotify_event*) dps->event_buf;
        3:  150:	const char *res = NULL;
        3:  151:	int ret = 0;
        3:  152:	FILE *file = NULL;
        -:  153:
        5:  154:	while(dps->active) {
        -:  155:		/* Blocking read until we get an event */
        5:  156:		ret = read(dps->inotify_fd, dps->event_buf, EVENT_LEN);
        5:  157:		if(ret < 0) {
    #####:  158:			if (errno == EINTR)
    #####:  159:				continue;
    #####:  160:			utils_perr("[DYNPS] Failed to read inotify fd, read()");
    #####:  161:			continue;
        -:  162:		}
        -:  163:
        5:  164:		utils_dbg("[DYNPS] filemon unblocked\n");
        -:  165:
        -:  166:		/* Got an ignore event, terminate */
        5:  167:		if(event->mask & IN_IGNORED)
        3:  168:			break;
        -:  169:
       2*:  170:		file = fopen(dps->filepath, "r");
       2*:  171:		if(!file) {
    #####:  172:			utils_perr("[DYNPS] Failed to open %s for reading PS, fopen()");
    #####:  173:			continue;
        -:  174:		}
        -:  175:
       2*:  176:		pthread_mutex_lock(&dps->dynps_proc_mutex);
       2*:  177:		memset(dps->string, 0, DYNPS_MAX_CHARS);
       2*:  178:		res = fgets(dps->string, DYNPS_MAX_CHARS, file);
       2*:  179:		if(!res) {
       1*:  180:			utils_perr("[DYNPS] Failed to get string from file, fgets()");
       1*:  181:			dps->string_len = 0;
        -:  182:		} else {
       1*:  183:			ret = rds_string_sanitize(dps->string, DYNPS_MAX_CHARS);
       1*:  184:			if(ret > 0) {
       1*:  185:				dps->string_len = ret;
       1*:  186:				dps->remaining_len = ret;
        -:  187:			} else
    #####:  188:				dps->string_len = 0;
        -:  189:		}
       2*:  190:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
       2*:  191:		fclose(file);
        -:  192:	}
        -:  193:
        3:  194:	utils_dbg("[DYNPS] Filemon terminated\n");
        3:  195:	return arg;
        -:  196:}
------------------
rds_dynps_filemon_thread:
        2:  146:rds_dynps_filemon_thread(void *arg)
        -:  147:{
        2:  148:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        2:  149:	const struct inotify_event *event = (struct inotify_event*) dps->event_buf;
        2:  150:	const char *res = NULL;
        2:  151:	int ret = 0;
        2:  152:	FILE *file = NULL;
        -:  153:
        4:  154:	while(dps->active) {
        -:  155:		/* Blocking read until we get an event */
        4:  156:		ret = read(dps->inotify_fd, dps->event_buf, EVENT_LEN);
        4:  157:		if(ret < 0) {
    #####:  158:			if (errno == EINTR)
    #####:  159:				continue;
    #####:  160:			utils_perr("[DYNPS] Failed to read inotify fd, read()");
    #####:  161:			continue;
        -:  162:		}
        -:  163:
        4:  164:		utils_dbg("[DYNPS] filemon unblocked\n");
        -:  165:
        -:  166:		/* Got an ignore event, terminate */
        4:  167:		if(event->mask & IN_IGNORED)
        2:  168:			break;
        -:  169:
        2:  170:		file = fopen(dps->filepath, "r");
        2:  171:		if(!file) {
    #####:  172:			utils_perr("[DYNPS] Failed to open %s for reading PS, fopen()");
    #####:  173:			continue;
        -:  174:		}
        -:  175:
        2:  176:		pthread_mutex_lock(&dps->dynps_proc_mutex);
        2:  177:		memset(dps->string, 0, DYNPS_MAX_CHARS);
        2:  178:		res = fgets(dps->string, DYNPS_MAX_CHARS, file);
        2:  179:		if(!res) {
        1:  180:			utils_perr("[DYNPS] Failed to get string from file, fgets()");
        1:  181:			dps->string_len = 0;
        -:  182:		} else {
        1:  183:			ret = rds_string_sanitize(dps->string, DYNPS_MAX_CHARS);
        1:  184:			if(ret > 0) {
        1:  185:				dps->string_len = ret;
        1:  186:				dps->remaining_len = ret;
        -:  187:			} else
    #####:  188:				dps->string_len = 0;
        -:  189:		}
        2:  190:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
        2:  191:		fclose(file);
        -:  192:	}
        -:  193:
        2:  194:	utils_dbg("[DYNPS] Filemon terminated\n");
        2:  195:	return arg;
        -:  196:}
------------------
rds_dynps_filemon_thread:
        1:  146:rds_dynps_filemon_thread(void *arg)
        -:  147:{
        1:  148:	struct rds_dynps_state *dps = (struct rds_dynps_state *) arg;
        1:  149:	const struct inotify_event *event = (struct inotify_event*) dps->event_buf;
        1:  150:	const char *res = NULL;
        1:  151:	int ret = 0;
        1:  152:	FILE *file = NULL;
        -:  153:
        1:  154:	while(dps->active) {
        -:  155:		/* Blocking read until we get an event */
        1:  156:		ret = read(dps->inotify_fd, dps->event_buf, EVENT_LEN);
        1:  157:		if(ret < 0) {
    #####:  158:			if (errno == EINTR)
    #####:  159:				continue;
    #####:  160:			utils_perr("[DYNPS] Failed to read inotify fd, read()");
    #####:  161:			continue;
        -:  162:		}
        -:  163:
        1:  164:		utils_dbg("[DYNPS] filemon unblocked\n");
        -:  165:
        -:  166:		/* Got an ignore event, terminate */
        1:  167:		if(event->mask & IN_IGNORED)
        1:  168:			break;
        -:  169:
    #####:  170:		file = fopen(dps->filepath, "r");
    #####:  171:		if(!file) {
    #####:  172:			utils_perr("[DYNPS] Failed to open %s for reading PS, fopen()");
    #####:  173:			continue;
        -:  174:		}
        -:  175:
    #####:  176:		pthread_mutex_lock(&dps->dynps_proc_mutex);
    #####:  177:		memset(dps->string, 0, DYNPS_MAX_CHARS);
    #####:  178:		res = fgets(dps->string, DYNPS_MAX_CHARS, file);
    #####:  179:		if(!res) {
    #####:  180:			utils_perr("[DYNPS] Failed to get string from file, fgets()");
    #####:  181:			dps->string_len = 0;
        -:  182:		} else {
    #####:  183:			ret = rds_string_sanitize(dps->string, DYNPS_MAX_CHARS);
    #####:  184:			if(ret > 0) {
    #####:  185:				dps->string_len = ret;
    #####:  186:				dps->remaining_len = ret;
        -:  187:			} else
    #####:  188:				dps->string_len = 0;
        -:  189:		}
    #####:  190:		pthread_mutex_unlock(&dps->dynps_proc_mutex);
    #####:  191:		fclose(file);
        -:  192:	}
        -:  193:
        1:  194:	utils_dbg("[DYNPS] Filemon terminated\n");
        1:  195:	return arg;
        -:  196:}
------------------
        -:  197:
        -:  198:void
        3:  199:rds_dynps_destroy(struct rds_dynps_state *dps)
        -:  200:{
        3:  201:	utils_dbg("[DYNPS] Graceful exit\n");
        -:  202:
        3:  203:	dps->active = 0;
        -:  204:
        3:  205:	pthread_mutex_lock(&dps->sleep_mutex);
        3:  206:	pthread_cond_signal(&dps->sleep_trig);
        3:  207:	pthread_mutex_unlock(&dps->sleep_mutex);
        -:  208:
        3:  209:	if(dps->dynps_consumer_tid)
        3:  210:		pthread_join(dps->dynps_consumer_tid, NULL);
        -:  211:
        3:  212:	if(dps->inotify_fd && dps->watch_fd)
        3:  213:		inotify_rm_watch(dps->inotify_fd, dps->watch_fd);
        -:  214:
        3:  215:	if(dps->inotify_fd)
        3:  216:		close(dps->inotify_fd);
        -:  217:
        3:  218:	if(dps->dynps_filemon_tid)
        3:  219:		pthread_join(dps->dynps_filemon_tid, NULL);
        -:  220:
        3:  221:	rds_set_ps(dps->st, dps->fixed_ps);
        -:  222:
        3:  223:	pthread_mutex_destroy(&dps->dynps_proc_mutex);
        3:  224:	pthread_mutex_destroy(&dps->sleep_mutex);
        3:  225:	pthread_cond_destroy(&dps->sleep_trig);
        3:  226:}
------------------
rds_dynps_destroy:
        2:  199:rds_dynps_destroy(struct rds_dynps_state *dps)
        -:  200:{
        2:  201:	utils_dbg("[DYNPS] Graceful exit\n");
        -:  202:
        2:  203:	dps->active = 0;
        -:  204:
        2:  205:	pthread_mutex_lock(&dps->sleep_mutex);
        2:  206:	pthread_cond_signal(&dps->sleep_trig);
        2:  207:	pthread_mutex_unlock(&dps->sleep_mutex);
        -:  208:
        2:  209:	if(dps->dynps_consumer_tid)
        2:  210:		pthread_join(dps->dynps_consumer_tid, NULL);
        -:  211:
        2:  212:	if(dps->inotify_fd && dps->watch_fd)
        2:  213:		inotify_rm_watch(dps->inotify_fd, dps->watch_fd);
        -:  214:
        2:  215:	if(dps->inotify_fd)
        2:  216:		close(dps->inotify_fd);
        -:  217:
        2:  218:	if(dps->dynps_filemon_tid)
        2:  219:		pthread_join(dps->dynps_filemon_tid, NULL);
        -:  220:
        2:  221:	rds_set_ps(dps->st, dps->fixed_ps);
        -:  222:
        2:  223:	pthread_mutex_destroy(&dps->dynps_proc_mutex);
        2:  224:	pthread_mutex_destroy(&dps->sleep_mutex);
        2:  225:	pthread_cond_destroy(&dps->sleep_trig);
        2:  226:}
------------------
rds_dynps_destroy:
        1:  199:rds_dynps_destroy(struct rds_dynps_state *dps)
        -:  200:{
        1:  201:	utils_dbg("[DYNPS] Graceful exit\n");
        -:  202:
        1:  203:	dps->active = 0;
        -:  204:
        1:  205:	pthread_mutex_lock(&dps->sleep_mutex);
        1:  206:	pthread_cond_signal(&dps->sleep_trig);
        1:  207:	pthread_mutex_unlock(&dps->sleep_mutex);
        -:  208:
        1:  209:	if(dps->dynps_consumer_tid)
        1:  210:		pthread_join(dps->dynps_consumer_tid, NULL);
        -:  211:
        1:  212:	if(dps->inotify_fd && dps->watch_fd)
        1:  213:		inotify_rm_watch(dps->inotify_fd, dps->watch_fd);
        -:  214:
        1:  215:	if(dps->inotify_fd)
        1:  216:		close(dps->inotify_fd);
        -:  217:
        1:  218:	if(dps->dynps_filemon_tid)
        1:  219:		pthread_join(dps->dynps_filemon_tid, NULL);
        -:  220:
        1:  221:	rds_set_ps(dps->st, dps->fixed_ps);
        -:  222:
        1:  223:	pthread_mutex_destroy(&dps->dynps_proc_mutex);
        1:  224:	pthread_mutex_destroy(&dps->sleep_mutex);
        1:  225:	pthread_cond_destroy(&dps->sleep_trig);
        1:  226:}
------------------
        -:  227:
        -:  228:int
        3:  229:rds_dynps_init(struct rds_dynps_state *dps, struct rds_encoder_state *st, const char* filepath)
        -:  230:{
        3:  231:	int ret = 0;
        -:  232:
        3:  233:	if(!st->ps_set) {
    #####:  234:		utils_wrn("[DYNPS] Fixed PS not set, dynamic PS request ignored\n");
    #####:  235:		return -1;
        -:  236:	}
        -:  237:
        3:  238:	memset(dps, 0, sizeof(struct rds_dynps_state));
        -:  239:
        3:  240:	dps->st = st;
        3:  241:	pthread_mutex_init(&dps->dynps_proc_mutex, NULL);
        3:  242:	pthread_mutex_init(&dps->sleep_mutex, NULL);
        3:  243:	pthread_cond_init(&dps->sleep_trig, NULL);
        -:  244:
        3:  245:	strncpy(dps->fixed_ps, st->ps, RDS_PS_LENGTH);
        -:  246:
        3:  247:	dps->inotify_fd = inotify_init();
        3:  248:	if(dps->inotify_fd < 0) {
    #####:  249:		utils_perr("[DYNPS] Unable to initialize inotify, inotify_init()");
    #####:  250:		ret = -2;
    #####:  251:		goto cleanup;
        -:  252:	}
        -:  253:
        3:  254:	dps->filepath = filepath;
        3:  255:	dps->watch_fd = inotify_add_watch(dps->inotify_fd, dps->filepath, IN_MODIFY | IN_IGNORED);
        3:  256:	if(dps->watch_fd < 0) {
    #####:  257:		utils_perr("[DYNPS] Unable to add inotify watch, inotify_add_watch()");
    #####:  258:		ret = -3;
    #####:  259:		goto cleanup;
        -:  260:	}
        -:  261:
        3:  262:	dps->active = 1;
        3:  263:	ret = pthread_create(&dps->dynps_filemon_tid, NULL,
        -:  264:			     rds_dynps_filemon_thread, (void*) dps);
        3:  265:	if(ret != 0) {
    #####:  266:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  267:		ret = -4;
    #####:  268:		goto cleanup;
        -:  269:	}
        -:  270:
        3:  271:	ret = pthread_create(&dps->dynps_consumer_tid, NULL,
        -:  272:			     rds_dynps_consumer_thread, (void*) dps);
        3:  273:	if(ret != 0) {
    #####:  274:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  275:		ret = -5;
    #####:  276:		goto cleanup;
        -:  277:	}
        -:  278:
        3:  279:	return ret;
        -:  280:
    #####:  281: cleanup:
    #####:  282:	rds_dynps_destroy(dps);
    #####:  283:	return ret;
        -:  284:}
------------------
rds_dynps_init:
        2:  229:rds_dynps_init(struct rds_dynps_state *dps, struct rds_encoder_state *st, const char* filepath)
        -:  230:{
        2:  231:	int ret = 0;
        -:  232:
        2:  233:	if(!st->ps_set) {
    #####:  234:		utils_wrn("[DYNPS] Fixed PS not set, dynamic PS request ignored\n");
    #####:  235:		return -1;
        -:  236:	}
        -:  237:
        2:  238:	memset(dps, 0, sizeof(struct rds_dynps_state));
        -:  239:
        2:  240:	dps->st = st;
        2:  241:	pthread_mutex_init(&dps->dynps_proc_mutex, NULL);
        2:  242:	pthread_mutex_init(&dps->sleep_mutex, NULL);
        2:  243:	pthread_cond_init(&dps->sleep_trig, NULL);
        -:  244:
        2:  245:	strncpy(dps->fixed_ps, st->ps, RDS_PS_LENGTH);
        -:  246:
        2:  247:	dps->inotify_fd = inotify_init();
        2:  248:	if(dps->inotify_fd < 0) {
    #####:  249:		utils_perr("[DYNPS] Unable to initialize inotify, inotify_init()");
    #####:  250:		ret = -2;
    #####:  251:		goto cleanup;
        -:  252:	}
        -:  253:
        2:  254:	dps->filepath = filepath;
        2:  255:	dps->watch_fd = inotify_add_watch(dps->inotify_fd, dps->filepath, IN_MODIFY | IN_IGNORED);
        2:  256:	if(dps->watch_fd < 0) {
    #####:  257:		utils_perr("[DYNPS] Unable to add inotify watch, inotify_add_watch()");
    #####:  258:		ret = -3;
    #####:  259:		goto cleanup;
        -:  260:	}
        -:  261:
        2:  262:	dps->active = 1;
        2:  263:	ret = pthread_create(&dps->dynps_filemon_tid, NULL,
        -:  264:			     rds_dynps_filemon_thread, (void*) dps);
        2:  265:	if(ret != 0) {
    #####:  266:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  267:		ret = -4;
    #####:  268:		goto cleanup;
        -:  269:	}
        -:  270:
        2:  271:	ret = pthread_create(&dps->dynps_consumer_tid, NULL,
        -:  272:			     rds_dynps_consumer_thread, (void*) dps);
        2:  273:	if(ret != 0) {
    #####:  274:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  275:		ret = -5;
    #####:  276:		goto cleanup;
        -:  277:	}
        -:  278:
        2:  279:	return ret;
        -:  280:
    #####:  281: cleanup:
    #####:  282:	rds_dynps_destroy(dps);
    #####:  283:	return ret;
        -:  284:}
------------------
rds_dynps_init:
        1:  229:rds_dynps_init(struct rds_dynps_state *dps, struct rds_encoder_state *st, const char* filepath)
        -:  230:{
        1:  231:	int ret = 0;
        -:  232:
        1:  233:	if(!st->ps_set) {
    #####:  234:		utils_wrn("[DYNPS] Fixed PS not set, dynamic PS request ignored\n");
    #####:  235:		return -1;
        -:  236:	}
        -:  237:
        1:  238:	memset(dps, 0, sizeof(struct rds_dynps_state));
        -:  239:
        1:  240:	dps->st = st;
        1:  241:	pthread_mutex_init(&dps->dynps_proc_mutex, NULL);
        1:  242:	pthread_mutex_init(&dps->sleep_mutex, NULL);
        1:  243:	pthread_cond_init(&dps->sleep_trig, NULL);
        -:  244:
        1:  245:	strncpy(dps->fixed_ps, st->ps, RDS_PS_LENGTH);
        -:  246:
        1:  247:	dps->inotify_fd = inotify_init();
        1:  248:	if(dps->inotify_fd < 0) {
    #####:  249:		utils_perr("[DYNPS] Unable to initialize inotify, inotify_init()");
    #####:  250:		ret = -2;
    #####:  251:		goto cleanup;
        -:  252:	}
        -:  253:
        1:  254:	dps->filepath = filepath;
        1:  255:	dps->watch_fd = inotify_add_watch(dps->inotify_fd, dps->filepath, IN_MODIFY | IN_IGNORED);
        1:  256:	if(dps->watch_fd < 0) {
    #####:  257:		utils_perr("[DYNPS] Unable to add inotify watch, inotify_add_watch()");
    #####:  258:		ret = -3;
    #####:  259:		goto cleanup;
        -:  260:	}
        -:  261:
        1:  262:	dps->active = 1;
        1:  263:	ret = pthread_create(&dps->dynps_filemon_tid, NULL,
        -:  264:			     rds_dynps_filemon_thread, (void*) dps);
        1:  265:	if(ret != 0) {
    #####:  266:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  267:		ret = -4;
    #####:  268:		goto cleanup;
        -:  269:	}
        -:  270:
        1:  271:	ret = pthread_create(&dps->dynps_consumer_tid, NULL,
        -:  272:			     rds_dynps_consumer_thread, (void*) dps);
        1:  273:	if(ret != 0) {
    #####:  274:		utils_err("[DYNPS] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  275:		ret = -5;
    #####:  276:		goto cleanup;
        -:  277:	}
        -:  278:
        1:  279:	return ret;
        -:  280:
    #####:  281: cleanup:
    #####:  282:	rds_dynps_destroy(dps);
    #####:  283:	return ret;
        -:  284:}
------------------
        -:  285:
        -:  286:
        -:  287:/*******************\
        -:  288:* DYNAMIC RadioText *
        -:  289:\*******************/
        -:  290:
        -:  291:static void*
        2:  292:rds_dynrt_consumer_thread(void *arg)
        -:  293:{
        2:  294:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        2:  295:	int ret = 0;
        -:  296:
       16:  297:	while(drt->active) {
       14:  298:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
       14:  299:		if(drt->num_segments) {
        -:  300:			/* Just rotate between the segments, ignore fixed_rt */
       8*:  301:			if(drt->curr_segment >= drt->num_segments)
       2*:  302:				drt->curr_segment = 0;
       8*:  303:			ret = rds_set_rt(drt->st, drt->rt_segments[drt->curr_segment], 1);
       8*:  304:			utils_dbg("[DYNRT] %s, status: %i\n",
       8*:  305:				  drt->rt_segments[drt->curr_segment], ret);
       8*:  306:			drt->curr_segment++;
        -:  307:		}
       14:  308:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
       14:  309:		rds_dynpsrt_cond_sleep(&drt->sleep_trig, &drt->sleep_mutex,
        -:  310:				       DYNPS_DELAY_SECS);
        -:  311:	}
        -:  312:
        2:  313:	utils_dbg("[DYNRT] Consumer terminated\n");
        2:  314:	return arg;
        -:  315:}
------------------
rds_dynrt_consumer_thread:
        1:  292:rds_dynrt_consumer_thread(void *arg)
        -:  293:{
        1:  294:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        1:  295:	int ret = 0;
        -:  296:
       12:  297:	while(drt->active) {
       11:  298:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
       11:  299:		if(drt->num_segments) {
        -:  300:			/* Just rotate between the segments, ignore fixed_rt */
        8:  301:			if(drt->curr_segment >= drt->num_segments)
        2:  302:				drt->curr_segment = 0;
        8:  303:			ret = rds_set_rt(drt->st, drt->rt_segments[drt->curr_segment], 1);
        8:  304:			utils_dbg("[DYNRT] %s, status: %i\n",
        8:  305:				  drt->rt_segments[drt->curr_segment], ret);
        8:  306:			drt->curr_segment++;
        -:  307:		}
       11:  308:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
       11:  309:		rds_dynpsrt_cond_sleep(&drt->sleep_trig, &drt->sleep_mutex,
        -:  310:				       DYNPS_DELAY_SECS);
        -:  311:	}
        -:  312:
        1:  313:	utils_dbg("[DYNRT] Consumer terminated\n");
        1:  314:	return arg;
        -:  315:}
------------------
rds_dynrt_consumer_thread:
        1:  292:rds_dynrt_consumer_thread(void *arg)
        -:  293:{
        1:  294:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        1:  295:	int ret = 0;
        -:  296:
        4:  297:	while(drt->active) {
        3:  298:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
        3:  299:		if(drt->num_segments) {
        -:  300:			/* Just rotate between the segments, ignore fixed_rt */
    #####:  301:			if(drt->curr_segment >= drt->num_segments)
    #####:  302:				drt->curr_segment = 0;
    #####:  303:			ret = rds_set_rt(drt->st, drt->rt_segments[drt->curr_segment], 1);
    #####:  304:			utils_dbg("[DYNRT] %s, status: %i\n",
    #####:  305:				  drt->rt_segments[drt->curr_segment], ret);
    #####:  306:			drt->curr_segment++;
        -:  307:		}
        3:  308:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
        3:  309:		rds_dynpsrt_cond_sleep(&drt->sleep_trig, &drt->sleep_mutex,
        -:  310:				       DYNPS_DELAY_SECS);
        -:  311:	}
        -:  312:
        1:  313:	utils_dbg("[DYNRT] Consumer terminated\n");
        1:  314:	return arg;
        -:  315:}
------------------
        -:  316:
        -:  317:static void*
        2:  318:rds_dynrt_filemon_thread(void *arg)
        -:  319:{
        2:  320:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        2:  321:	const struct inotify_event *event = (struct inotify_event*) drt->event_buf;
        2:  322:	char *res = NULL;
        2:  323:	int ret = 0;
        2:  324:	size_t len = 0;
        2:  325:	FILE *file = NULL;
        2:  326:	int i = 0;
        -:  327:
        4:  328:	while(drt->active) {
        -:  329:		/* Blocking read until we get an event */
        4:  330:		ret = read(drt->inotify_fd, drt->event_buf, EVENT_LEN);
        4:  331:		if(ret < 0) {
    #####:  332:			if (errno == EINTR)
    #####:  333:				continue;
    #####:  334:			utils_perr("[DYNRT] Failed to read inotify fd, read()");
    #####:  335:			continue;
        -:  336:		}
        -:  337:
        4:  338:		utils_dbg("[DYNRT] filemon unblocked\n");
        -:  339:
        -:  340:		/* Got an ignore event, terminate */
        4:  341:		if(event->mask & IN_IGNORED)
        2:  342:			break;
        -:  343:
       2*:  344:		file = fopen(drt->filepath, "r");
       2*:  345:		if(!file) {
    #####:  346:			utils_perr("[DYNRT] Failed to open %s for reading RT segments, fopen()");
    #####:  347:			continue;
        -:  348:		}
        -:  349:
       2*:  350:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
       2*:  351:		drt->num_segments = 0;
       5*:  352:		for(i = 0; i < DYNRT_MAX_SEGMENTS; i++) {
       4*:  353:			ret = getline(&res, &len, file);
       4*:  354:			if(ret > RDS_RT_LENGTH) {
    #####:  355:				utils_wrn("[DYNRT] Ignoring line longer than 64 chars\n");
    #####:  356:				break;
       4*:  357:			} else if(ret < 0) {
       1*:  358:				if(errno)
    #####:  359:					utils_perr("[DYNRT] Failed to read from file, getline()");
       1*:  360:				else if(i == 0)
       1*:  361:					utils_wrn("[DYNRT] Failed to read any lines from file\n");
        -:  362:				else
    #####:  363:					utils_dbg("[DYNRT] Got %u lines from file\n", i);
       1*:  364:				break;
        -:  365:			}
        -:  366:
       3*:  367:			ret = rds_string_sanitize(res, len);
       3*:  368:			if(ret < 0) {
    #####:  369:				utils_wrn("[DYNRT] Malformed string, error: %i\n", ret);
    #####:  370:				break;
        -:  371:			}
        -:  372:
       3*:  373:			memset(drt->rt_segments[drt->num_segments], 0, RDS_RT_LENGTH + 1);
       3*:  374:			strncpy(drt->rt_segments[drt->num_segments], res, ret);
       3*:  375:			drt->num_segments++;
        -:  376:		}
       2*:  377:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
       2*:  378:		fclose(file);
        -:  379:
        -:  380:		/* If we didn't get anything, fallback to fixed_rt */
       2*:  381:		if(drt->num_segments == 0) {
       1*:  382:			ret = rds_set_rt(drt->st, drt->fixed_rt, 1);
       1*:  383:			utils_dbg("[DYNRT] %s, status: %i (fallback)\n", drt->fixed_rt, ret);
        -:  384:		}
        -:  385:	}
        -:  386:
        2:  387:	free(res);
        2:  388:	utils_dbg("[DYNRT] Filemon terminated\n");
        2:  389:	return arg;
        -:  390:}
------------------
rds_dynrt_filemon_thread:
        1:  318:rds_dynrt_filemon_thread(void *arg)
        -:  319:{
        1:  320:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        1:  321:	const struct inotify_event *event = (struct inotify_event*) drt->event_buf;
        1:  322:	char *res = NULL;
        1:  323:	int ret = 0;
        1:  324:	size_t len = 0;
        1:  325:	FILE *file = NULL;
        1:  326:	int i = 0;
        -:  327:
        3:  328:	while(drt->active) {
        -:  329:		/* Blocking read until we get an event */
        3:  330:		ret = read(drt->inotify_fd, drt->event_buf, EVENT_LEN);
        3:  331:		if(ret < 0) {
    #####:  332:			if (errno == EINTR)
    #####:  333:				continue;
    #####:  334:			utils_perr("[DYNRT] Failed to read inotify fd, read()");
    #####:  335:			continue;
        -:  336:		}
        -:  337:
        3:  338:		utils_dbg("[DYNRT] filemon unblocked\n");
        -:  339:
        -:  340:		/* Got an ignore event, terminate */
        3:  341:		if(event->mask & IN_IGNORED)
        1:  342:			break;
        -:  343:
        2:  344:		file = fopen(drt->filepath, "r");
        2:  345:		if(!file) {
    #####:  346:			utils_perr("[DYNRT] Failed to open %s for reading RT segments, fopen()");
    #####:  347:			continue;
        -:  348:		}
        -:  349:
        2:  350:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
        2:  351:		drt->num_segments = 0;
        5:  352:		for(i = 0; i < DYNRT_MAX_SEGMENTS; i++) {
        4:  353:			ret = getline(&res, &len, file);
        4:  354:			if(ret > RDS_RT_LENGTH) {
    #####:  355:				utils_wrn("[DYNRT] Ignoring line longer than 64 chars\n");
    #####:  356:				break;
        4:  357:			} else if(ret < 0) {
        1:  358:				if(errno)
    #####:  359:					utils_perr("[DYNRT] Failed to read from file, getline()");
        1:  360:				else if(i == 0)
        1:  361:					utils_wrn("[DYNRT] Failed to read any lines from file\n");
        -:  362:				else
    #####:  363:					utils_dbg("[DYNRT] Got %u lines from file\n", i);
        1:  364:				break;
        -:  365:			}
        -:  366:
        3:  367:			ret = rds_string_sanitize(res, len);
        3:  368:			if(ret < 0) {
    #####:  369:				utils_wrn("[DYNRT] Malformed string, error: %i\n", ret);
    #####:  370:				break;
        -:  371:			}
        -:  372:
        3:  373:			memset(drt->rt_segments[drt->num_segments], 0, RDS_RT_LENGTH + 1);
        3:  374:			strncpy(drt->rt_segments[drt->num_segments], res, ret);
        3:  375:			drt->num_segments++;
        -:  376:		}
        2:  377:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
        2:  378:		fclose(file);
        -:  379:
        -:  380:		/* If we didn't get anything, fallback to fixed_rt */
        2:  381:		if(drt->num_segments == 0) {
        1:  382:			ret = rds_set_rt(drt->st, drt->fixed_rt, 1);
        1:  383:			utils_dbg("[DYNRT] %s, status: %i (fallback)\n", drt->fixed_rt, ret);
        -:  384:		}
        -:  385:	}
        -:  386:
        1:  387:	free(res);
        1:  388:	utils_dbg("[DYNRT] Filemon terminated\n");
        1:  389:	return arg;
        -:  390:}
------------------
rds_dynrt_filemon_thread:
        1:  318:rds_dynrt_filemon_thread(void *arg)
        -:  319:{
        1:  320:	struct rds_dynrt_state *drt = (struct rds_dynrt_state *) arg;
        1:  321:	const struct inotify_event *event = (struct inotify_event*) drt->event_buf;
        1:  322:	char *res = NULL;
        1:  323:	int ret = 0;
        1:  324:	size_t len = 0;
        1:  325:	FILE *file = NULL;
        1:  326:	int i = 0;
        -:  327:
        1:  328:	while(drt->active) {
        -:  329:		/* Blocking read until we get an event */
        1:  330:		ret = read(drt->inotify_fd, drt->event_buf, EVENT_LEN);
        1:  331:		if(ret < 0) {
    #####:  332:			if (errno == EINTR)
    #####:  333:				continue;
    #####:  334:			utils_perr("[DYNRT] Failed to read inotify fd, read()");
    #####:  335:			continue;
        -:  336:		}
        -:  337:
        1:  338:		utils_dbg("[DYNRT] filemon unblocked\n");
        -:  339:
        -:  340:		/* Got an ignore event, terminate */
        1:  341:		if(event->mask & IN_IGNORED)
        1:  342:			break;
        -:  343:
    #####:  344:		file = fopen(drt->filepath, "r");
    #####:  345:		if(!file) {
    #####:  346:			utils_perr("[DYNRT] Failed to open %s for reading RT segments, fopen()");
    #####:  347:			continue;
        -:  348:		}
        -:  349:
    #####:  350:		pthread_mutex_lock(&drt->dynrt_proc_mutex);
    #####:  351:		drt->num_segments = 0;
    #####:  352:		for(i = 0; i < DYNRT_MAX_SEGMENTS; i++) {
    #####:  353:			ret = getline(&res, &len, file);
    #####:  354:			if(ret > RDS_RT_LENGTH) {
    #####:  355:				utils_wrn("[DYNRT] Ignoring line longer than 64 chars\n");
    #####:  356:				break;
    #####:  357:			} else if(ret < 0) {
    #####:  358:				if(errno)
    #####:  359:					utils_perr("[DYNRT] Failed to read from file, getline()");
    #####:  360:				else if(i == 0)
    #####:  361:					utils_wrn("[DYNRT] Failed to read any lines from file\n");
        -:  362:				else
    #####:  363:					utils_dbg("[DYNRT] Got %u lines from file\n", i);
    #####:  364:				break;
        -:  365:			}
        -:  366:
    #####:  367:			ret = rds_string_sanitize(res, len);
    #####:  368:			if(ret < 0) {
    #####:  369:				utils_wrn("[DYNRT] Malformed string, error: %i\n", ret);
    #####:  370:				break;
        -:  371:			}
        -:  372:
    #####:  373:			memset(drt->rt_segments[drt->num_segments], 0, RDS_RT_LENGTH + 1);
    #####:  374:			strncpy(drt->rt_segments[drt->num_segments], res, ret);
    #####:  375:			drt->num_segments++;
        -:  376:		}
    #####:  377:		pthread_mutex_unlock(&drt->dynrt_proc_mutex);
    #####:  378:		fclose(file);
        -:  379:
        -:  380:		/* If we didn't get anything, fallback to fixed_rt */
    #####:  381:		if(drt->num_segments == 0) {
    #####:  382:			ret = rds_set_rt(drt->st, drt->fixed_rt, 1);
    #####:  383:			utils_dbg("[DYNRT] %s, status: %i (fallback)\n", drt->fixed_rt, ret);
        -:  384:		}
        -:  385:	}
        -:  386:
        1:  387:	free(res);
        1:  388:	utils_dbg("[DYNRT] Filemon terminated\n");
        1:  389:	return arg;
        -:  390:}
------------------
        -:  391:
        -:  392:void
        2:  393:rds_dynrt_destroy(struct rds_dynrt_state *drt)
        -:  394:{
        2:  395:	utils_dbg("[DYNRT] Graceful exit\n");
        -:  396:
        2:  397:	drt->active = 0;
        -:  398:
        2:  399:	pthread_mutex_lock(&drt->sleep_mutex);
        2:  400:	pthread_cond_signal(&drt->sleep_trig);
        2:  401:	pthread_mutex_unlock(&drt->sleep_mutex);
        -:  402:
        2:  403:	if(drt->dynrt_consumer_tid)
        2:  404:		pthread_join(drt->dynrt_consumer_tid, NULL);
        -:  405:
        2:  406:	if(drt->inotify_fd && drt->watch_fd)
        2:  407:		inotify_rm_watch(drt->inotify_fd, drt->watch_fd);
        -:  408:
        2:  409:	if(drt->inotify_fd)
        2:  410:		close(drt->inotify_fd);
        -:  411:
        2:  412:	if(drt->dynrt_filemon_tid)
        2:  413:		pthread_join(drt->dynrt_filemon_tid, NULL);
        -:  414:
        2:  415:	rds_set_rt(drt->st, drt->fixed_rt, 1);
        -:  416:
        2:  417:	pthread_mutex_destroy(&drt->dynrt_proc_mutex);
        2:  418:	pthread_mutex_destroy(&drt->sleep_mutex);
        2:  419:	pthread_cond_destroy(&drt->sleep_trig);
        2:  420:}
------------------
rds_dynrt_destroy:
        1:  393:rds_dynrt_destroy(struct rds_dynrt_state *drt)
        -:  394:{
        1:  395:	utils_dbg("[DYNRT] Graceful exit\n");
        -:  396:
        1:  397:	drt->active = 0;
        -:  398:
        1:  399:	pthread_mutex_lock(&drt->sleep_mutex);
        1:  400:	pthread_cond_signal(&drt->sleep_trig);
        1:  401:	pthread_mutex_unlock(&drt->sleep_mutex);
        -:  402:
        1:  403:	if(drt->dynrt_consumer_tid)
        1:  404:		pthread_join(drt->dynrt_consumer_tid, NULL);
        -:  405:
        1:  406:	if(drt->inotify_fd && drt->watch_fd)
        1:  407:		inotify_rm_watch(drt->inotify_fd, drt->watch_fd);
        -:  408:
        1:  409:	if(drt->inotify_fd)
        1:  410:		close(drt->inotify_fd);
        -:  411:
        1:  412:	if(drt->dynrt_filemon_tid)
        1:  413:		pthread_join(drt->dynrt_filemon_tid, NULL);
        -:  414:
        1:  415:	rds_set_rt(drt->st, drt->fixed_rt, 1);
        -:  416:
        1:  417:	pthread_mutex_destroy(&drt->dynrt_proc_mutex);
        1:  418:	pthread_mutex_destroy(&drt->sleep_mutex);
        1:  419:	pthread_cond_destroy(&drt->sleep_trig);
        1:  420:}
------------------
rds_dynrt_destroy:
        1:  393:rds_dynrt_destroy(struct rds_dynrt_state *drt)
        -:  394:{
        1:  395:	utils_dbg("[DYNRT] Graceful exit\n");
        -:  396:
        1:  397:	drt->active = 0;
        -:  398:
        1:  399:	pthread_mutex_lock(&drt->sleep_mutex);
        1:  400:	pthread_cond_signal(&drt->sleep_trig);
        1:  401:	pthread_mutex_unlock(&drt->sleep_mutex);
        -:  402:
        1:  403:	if(drt->dynrt_consumer_tid)
        1:  404:		pthread_join(drt->dynrt_consumer_tid, NULL);
        -:  405:
        1:  406:	if(drt->inotify_fd && drt->watch_fd)
        1:  407:		inotify_rm_watch(drt->inotify_fd, drt->watch_fd);
        -:  408:
        1:  409:	if(drt->inotify_fd)
        1:  410:		close(drt->inotify_fd);
        -:  411:
        1:  412:	if(drt->dynrt_filemon_tid)
        1:  413:		pthread_join(drt->dynrt_filemon_tid, NULL);
        -:  414:
        1:  415:	rds_set_rt(drt->st, drt->fixed_rt, 1);
        -:  416:
        1:  417:	pthread_mutex_destroy(&drt->dynrt_proc_mutex);
        1:  418:	pthread_mutex_destroy(&drt->sleep_mutex);
        1:  419:	pthread_cond_destroy(&drt->sleep_trig);
        1:  420:}
------------------
        -:  421:
        -:  422:int
        2:  423:rds_dynrt_init(struct rds_dynrt_state *drt, struct rds_encoder_state *st, const char* filepath)
        -:  424:{
        2:  425:	int ret = 0;
        -:  426:
        2:  427:	if(!st->rt_set) {
    #####:  428:		utils_wrn("[DYNRT] Fixed RT not set, dynamic RT request ignored\n");
    #####:  429:		return -1;
        -:  430:	}
        -:  431:
        2:  432:	memset(drt, 0, sizeof(struct rds_dynrt_state));
        -:  433:
        2:  434:	drt->st = st;
        2:  435:	pthread_mutex_init(&drt->dynrt_proc_mutex, NULL);
        2:  436:	pthread_mutex_init(&drt->sleep_mutex, NULL);
        2:  437:	pthread_cond_init(&drt->sleep_trig, NULL);
        -:  438:
        2:  439:	strncpy(drt->fixed_rt, st->rt, RDS_RT_LENGTH);
        -:  440:
        2:  441:	drt->inotify_fd = inotify_init();
        2:  442:	if(drt->inotify_fd < 0) {
    #####:  443:		utils_perr("[DYNRT] Unable to initialize inotify, inotify_init()");
    #####:  444:		ret = -2;
    #####:  445:		goto cleanup;
        -:  446:	}
        -:  447:
        2:  448:	drt->filepath = filepath;
        2:  449:	drt->watch_fd = inotify_add_watch(drt->inotify_fd, drt->filepath, IN_MODIFY | IN_IGNORED);
        2:  450:	if(drt->watch_fd < 0) {
    #####:  451:		utils_perr("[DYNRT] Unable to add inotify watch, inotify_add_watch()");
    #####:  452:		ret = -3;
    #####:  453:		goto cleanup;
        -:  454:	}
        -:  455:
        2:  456:	drt->active = 1;
        2:  457:	ret = pthread_create(&drt->dynrt_filemon_tid, NULL,
        -:  458:			     rds_dynrt_filemon_thread, (void*) drt);
        2:  459:	if(ret != 0) {
    #####:  460:		utils_err("[DYNRT] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  461:		ret = -4;
    #####:  462:		goto cleanup;
        -:  463:	}
        -:  464:
        2:  465:	ret = pthread_create(&drt->dynrt_consumer_tid, NULL,
        -:  466:			     rds_dynrt_consumer_thread, (void*) drt);
        2:  467:	if(ret != 0) {
    #####:  468:		utils_err("[DYNRT] Unable to create file monitor thread, pthred_create(): %d", ret);
    #####:  469:		ret = -5;
    #####:  470:		goto cleanup;
        -:  471:	}
        -:  472:
        2:  473:	return ret;
        -:  474:
    #####:  475: cleanup:
    #####:  476:	rds_dynrt_destroy(drt);
    #####:  477:	return ret;
        -:  478:}

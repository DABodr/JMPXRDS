        -:    0:Source:gui/jmrg_switch.c
        -:    1:#include <stdlib.h>	/* For malloc() */
        -:    2:#include <string.h>	/* For memset() */
        -:    3:#include "jmpxrds_gui.h"
        -:    4:
        -:    5:/******************\
        -:    6:* POLLING FUNCTION *
        -:    7:\******************/
        -:    8:
        -:    9:static gboolean
     1137:   10:jmrg_switch_poll(gpointer data)
        -:   11:{
     1137:   12:	struct value_map *vmap = (struct value_map*) data;
     1137:   13:	int active = (int) gtk_switch_get_active(GTK_SWITCH(vmap->target));
        -:   14:
    1137*:   15:	if(!GTK_IS_SWITCH(vmap->target))
    #####:   16:		return FALSE;
        -:   17:
     1137:   18:	if(!gtk_widget_is_visible(vmap->target))
      628:   19:		return TRUE;
        -:   20:
      509:   21:	if(gtk_widget_has_focus(vmap->target))
    #####:   22:		return TRUE;
        -:   23:
      509:   24:	if(active && (*(uint8_t*)vmap->val_ptr))
      377:   25:		return TRUE;
        -:   26:
      132:   27:	gtk_switch_set_active(GTK_SWITCH(vmap->target),
      132:   28:			      (*(uint8_t*)vmap->val_ptr) ? 1 : 0);
        -:   29:
      132:   30:	return TRUE;
        -:   31:}
        -:   32:
        -:   33:
        -:   34:/*****************\
        -:   35:* SIGNAL HANDLERS *
        -:   36:\*****************/
        -:   37:
        -:   38:static gboolean
        4:   39:jmrg_switch_toggle(__attribute__((unused)) GtkSwitch *widget,
        -:   40:		   gboolean state, gpointer data)
        -:   41:{
        4:   42:	uint8_t *val = (uint8_t*) data;
        4:   43:	(*val) = state ? 1 : 0;
        -:   44:
        -:   45:	/* Let the default handler run */
        4:   46:	return FALSE;
        -:   47:}
        -:   48:
        -:   49:
        -:   50:/*************\
        -:   51:* ENTRY POINT *
        -:   52:\*************/
        -:   53:
        -:   54:GtkWidget*
        2:   55:jmrg_switch_init(const char* desc, int *val_ptr)
        -:   56:{
        2:   57:	GtkWidget *hbox = NULL;
        2:   58:	GtkWidget *label = NULL;
        2:   59:	GtkWidget *sw = NULL;
        2:   60:	struct value_map *vmap = NULL;
        -:   61:
        -:   62:	/* But the switch and its label together
        -:   63:	 * in a horizontal box */
        2:   64:	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
        2:   65:	if(!hbox)
    #####:   66:		return NULL;
        -:   67:
        2:   68:	sw = gtk_switch_new();
        2:   69:	if(!sw)
    #####:   70:		goto cleanup;
        2:   71:	gtk_box_pack_start(GTK_BOX(hbox), sw, FALSE, FALSE, 6);
        -:   72:
        2:   73:	label = gtk_label_new(desc);
        2:   74:	if(!label)
    #####:   75:		goto cleanup;
        2:   76:	gtk_box_pack_end(GTK_BOX(hbox), label, FALSE, FALSE, 6);
        -:   77:
        -:   78:
        -:   79:	/* Initialize value_map */
        2:   80:	vmap = (struct value_map*) malloc(sizeof(struct value_map));
        2:   81:	if(!vmap)
    #####:   82:		goto cleanup;
        2:   83:	memset(vmap, 0, sizeof(struct value_map));
        -:   84:
        2:   85:	vmap->target = sw;
        2:   86:	vmap->val_ptr = val_ptr;
        -:   87:
        -:   88:	/* Register polling function and signal handlers */
        2:   89:	vmap->esid = g_timeout_add(200, jmrg_switch_poll, vmap);
        -:   90:
        2:   91:	g_signal_connect(sw, "state-set", G_CALLBACK(jmrg_switch_toggle),
        -:   92:			 val_ptr);
        -:   93:
        2:   94:	g_signal_connect(sw, "unrealize", G_CALLBACK(jmrg_free_vmap),
        -:   95:			 vmap);
        -:   96:
        2:   97:	return hbox;
    #####:   98: cleanup:
    #####:   99:	if(sw)
    #####:  100:		gtk_widget_destroy(sw);
    #####:  101:	if(label)
    #####:  102:		gtk_widget_destroy(label);
    #####:  103:	if(hbox)
    #####:  104:		gtk_widget_destroy(hbox);
    #####:  105:	return NULL;
        -:  106:}

        -:    0:Source:gui/jmrg_mpx_plotter.c
        -:    1:#include <stdlib.h>	/* For malloc() / free() */
        -:    2:#include <string.h>	/* For memset() */
        -:    3:#include <math.h>	/* For pow() / sqrt() / log10() */
        -:    4:#include "jmrg_mpx_plotter.h"
        -:    5:
        -:    6:/*********\
        -:    7:* HELPERS *
        -:    8:\*********/
        -:    9:
        -:   10:static int
        1:   11:jmrg_mpxp_create_grid_points(struct mpx_plotter *mpxp)
        -:   12:{
        1:   13:	float div = 2.0 / 12.0;
        1:   14:	int i = 0;
        1:   15:	float j = 0;
        -:   16:
        -:   17:	/* Horizonal lines -> 5KHz steps
        -:   18:	 * Vertical lines -> 5dB steps
        -:   19:	 * Since we have 60KHz on x and 60dB on y we 'll need
        -:   20:	 * 12 horizonal and vertical lines, since each line needs
        -:   21:	 * 2 points we need 2 * 2 * 12 = 48 points */
        1:   22:	mpxp->points = (struct grid_point*)
        1:   23:		       malloc(48 * sizeof(struct grid_point));
        1:   24:	if(!mpxp->points)
    #####:   25:		return -1;
        -:   26:
        -:   27:	/* Horizonal lines: (-1,div) - (1, div) */
       13:   28:	for(i = 0, j = -1.0; i < 24; i++, j+= div) {
       12:   29:		mpxp->points[i].x = -1.0;
       12:   30:		mpxp->points[i].y = j;
        -:   31:
       12:   32:		i++;
        -:   33:
       12:   34:		mpxp->points[i].x = 1.0;
       12:   35:		mpxp->points[i].y = j;
        -:   36:	}
        -:   37:
        -:   38:	/* Vertical lines: (div, -1) - (div, 1) */
       13:   39:	for(i = 24, j = -1.0; i < 48; i++, j+= div) {
       12:   40:		mpxp->points[i].x = j;
       12:   41:		mpxp->points[i].y = -1.0;
        -:   42:
       12:   43:		i++;
        -:   44:
       12:   45:		mpxp->points[i].x = j;
       12:   46:		mpxp->points[i].y = 1.0;
        -:   47:	}
        -:   48:
        1:   49:	return 0;
        -:   50:}
        -:   51:
        -:   52:
        -:   53:/***************\
        -:   54:* DATA HANDLING *
        -:   55:\***************/
        -:   56:
        -:   57:static void
      286:   58:jmrg_mpxp_update_y_vals(struct mpx_plotter *mpxp)
        -:   59:{
      286:   60:	float norm = 1.0 / (float) mpxp->num_bins;
      286:   61:	float mag = 0.0;
      286:   62:	float db = 0.0;
      286:   63:	float scaled = 0.0;
      286:   64:	int i = 0;
      286:   65:	int ret = 0;
        -:   66:	static int skip = 0;
        -:   67:	FILE	*sock;
        -:   68:
        -:   69:	/* Got an underrun, give it some time
        -:   70:	 * to recover */
      286:   71:	if(skip) {
    #####:   72:		skip = 0;
    #####:   73:		return;
        -:   74:	}
        -:   75:
      286:   76:	sock = fopen(mpxp->sockpath, "rb");
      286:   77:	if(sock == NULL) {
    #####:   78:		utils_perr("[MPX PLOTTER] Could not open socket");
    #####:   79:		return;
        -:   80:	}
        -:   81:
      572:   82:	ret = fread((void*) mpxp->real_buff, sizeof(float),
      286:   83:		    mpxp->max_samples, sock);
      286:   84:	fclose(sock);
      286:   85:	if(ret != mpxp->max_samples) {
    #####:   86:		utils_perr("[MPX PLOTTER] Could not read from socket");
    #####:   87:		skip = 1;
    #####:   88:		return;
        -:   89:	}
        -:   90:
      286:   91:	fftwf_execute(mpxp->dft_plan);
        -:   92:
   435006:   93:	for(i = 0; i < mpxp->drawable_bins; i++) {
   434720:   94:		mag = powf(mpxp->complex_buff[i][0], 2) +
   434720:   95:		      powf(mpxp->complex_buff[i][1], 2);
   434720:   96:		mag = sqrtf(mag) * norm;
   434720:   97:		db = 20 * log10f(mag);
        -:   98:		/* We want a range from -60 to 0, so -60 -> -1, 0 -> 1 */
   434720:   99:		if(db <= -60)
   375237:  100:			scaled = -1;
    59483:  101:		else if(db >= 0)
    #####:  102:			scaled = 1;
        -:  103:		else
    59483:  104:			scaled = (db + 30.0L) / 30.0L;
        -:  105:
   434720:  106:		if(mpxp->avg) {
    #####:  107:			mpxp->y_vals[i] -= 0.008;
    #####:  108:			if(scaled > mpxp->y_vals[i])
    #####:  109:				mpxp->y_vals[i] = scaled;
        -:  110:		} else
   434720:  111:			mpxp->y_vals[i] = scaled;
        -:  112:
   434720:  113:		if(scaled > mpxp->y_peak_vals[i])
     5064:  114:			mpxp->y_peak_vals[i] = scaled;
        -:  115:	}
      286:  116:	return;
        -:  117:}
        -:  118:
        -:  119:
        -:  120:/******************\
        -:  121:* POLLING FUNCTION *
        -:  122:\******************/
        -:  123:
        -:  124:static gboolean
     1299:  125:jmrg_mpxp_redraw(gpointer data)
        -:  126:{
     1299:  127:	struct mpx_plotter *mpxp = (struct mpx_plotter*) data;
        -:  128:
     1299:  129:	if(!gtk_widget_is_visible(mpxp->glarea))
     1013:  130:		return TRUE;
        -:  131:
      286:  132:	jmrg_mpxp_update_y_vals(mpxp);
        -:  133:
      286:  134:	gtk_widget_queue_draw(mpxp->glarea);
      286:  135:	return TRUE;
        -:  136:}
        -:  137:
        -:  138:
        -:  139:/*****************\
        -:  140:* SIGNAL HANDLERS *
        -:  141:\*****************/
        -:  142:
        -:  143:static void
    #####:  144:jmrg_mpxp_toggle_avg(__attribute__((unused)) GtkToggleButton *togglebutton,
        -:  145:		     gpointer data)
        -:  146:{
    #####:  147:	struct mpx_plotter *mpxp = (struct mpx_plotter*) data;
    #####:  148:	mpxp->avg = (mpxp->avg) ? 0 : 1;
    #####:  149:	return;
        -:  150:}
        -:  151:
        -:  152:static void
    #####:  153:jmrg_mpxp_toggle_mh(__attribute__((unused)) GtkToggleButton *togglebutton,
        -:  154:		    gpointer data)
        -:  155:{
    #####:  156:	struct mpx_plotter *mpxp = (struct mpx_plotter*) data;
    #####:  157:	int i = 0;
        -:  158:
    #####:  159:	mpxp->max_hold = (mpxp->max_hold) ? 0 : 1;
        -:  160:
    #####:  161:	for(i = 0; i < mpxp->drawable_bins; i++)
    #####:  162:		mpxp->y_peak_vals[i] = -1.0;
        -:  163:
    #####:  164:	return;
        -:  165:}
        -:  166:
        -:  167:static void
        1:  168:jmrg_mpxp_destroy(__attribute__((unused)) GtkWidget *widget,
        -:  169:		  struct mpx_plotter *mpxp)
        -:  170:{
        1:  171:	const struct timespec tv = {0, 83000000L};
        -:  172:
        1:  173:	if(!mpxp)
    #####:  174:		return;
        -:  175:
        1:  176:	g_source_remove(mpxp->esid);
        1:  177:	nanosleep(&tv, NULL);
        -:  178:
        1:  179:	jmrg_mpxp_gl_destroy(GTK_GL_AREA(mpxp->glarea), mpxp);
        -:  180:
        1:  181:	if(mpxp->x_vals)
        1:  182:		free(mpxp->x_vals);
        1:  183:	if(mpxp->y_vals)
        1:  184:		free(mpxp->y_vals);
        1:  185:	if(mpxp->y_peak_vals)
        1:  186:		free(mpxp->y_peak_vals);
        1:  187:	if(mpxp->points)
        1:  188:		free(mpxp->points);
        1:  189:	if(mpxp->complex_buff)
        1:  190:		fftwf_free(mpxp->complex_buff);
        1:  191:	if(mpxp->real_buff)
        1:  192:		fftwf_free(mpxp->real_buff);
        1:  193:	if(mpxp->dft_plan)
        1:  194:		fftwf_destroy_plan(mpxp->dft_plan);
        1:  195:	free(mpxp);
        -:  196:
        1:  197:	return;
        -:  198:}
        -:  199:
        -:  200:
        -:  201:/*************\
        -:  202:* ENTRY POINT *
        -:  203:\*************/
        -:  204:
        -:  205:GtkWidget*
        1:  206:jmrg_mpx_plotter_init(int sample_rate, int max_samples)
        -:  207:{
        1:  208:	GtkWidget *container = NULL;
        1:  209:	GtkWidget *glarea = NULL;
        1:  210:	GtkWidget *button_box = NULL;
        1:  211:	GtkWidget *avg_tbutton = NULL;
        1:  212:	GtkWidget *mh_tbutton = NULL;
        1:  213:	uint32_t nyquist_freq = 0;
        1:  214:	double passband_ratio = 0.0;
        1:  215:	int middle_point = 0;
        1:  216:	struct mpx_plotter *mpxp = NULL;
        1:  217:	int ret = 0;
        1:  218:	int i = 0;
        -:  219:
        1:  220:	mpxp = (struct mpx_plotter*) malloc(sizeof(struct mpx_plotter));
        1:  221:	if(!mpxp) {
    #####:  222:		ret = -1;
    #####:  223:		goto cleanup;
        -:  224:	}
        1:  225:	memset(mpxp, 0, sizeof(struct mpx_plotter));
        -:  226:
        -:  227:	/* Prepare socket's path for reading samples */
        1:  228:	snprintf(mpxp->sockpath, 32, "/run/user/%i/jmpxrds.sock", getuid());
        -:  229:
        -:  230:	/* Initialize default state */
        1:  231:	mpxp->sample_rate = sample_rate;
        1:  232:	mpxp->max_samples = max_samples;
        1:  233:	mpxp->num_bins = max_samples;
        1:  234:	mpxp->half_bins = (mpxp->num_bins / 2) + 1;
        1:  235:	mpxp->max_hold = 0;
        1:  236:	mpxp->avg = 0;
        -:  237:
        -:  238:	/* We only want to draw up to 60KHz, half_bins
        -:  239:	 * contain the whole spectrum up to nyquist_freq */
        1:  240:	nyquist_freq = sample_rate / 2;
        1:  241:	passband_ratio = (double) 60000.0L / (double) nyquist_freq;
        1:  242:	mpxp->drawable_bins = (uint16_t)
        1:  243:			      (passband_ratio * (double) mpxp->half_bins);
        -:  244:
        -:  245:	/* Our plot can't be smaller than 120x120 since the grid won't fit */
        1:  246:	if(mpxp->drawable_bins < 120) {
    #####:  247:		ret = -1;
    #####:  248:		goto cleanup;
        -:  249:	}
        -:  250:
        -:  251:	/* Allocate buffers */
        1:  252:	mpxp->real_buff = fftwf_alloc_real(mpxp->max_samples);
        1:  253:	if(!mpxp->real_buff) {
    #####:  254:		ret = -3;
    #####:  255:		goto cleanup;
        -:  256:	}
        -:  257:
        1:  258:	mpxp->complex_buff = fftwf_alloc_complex(mpxp->half_bins);
        1:  259:	if(!mpxp->complex_buff) {
    #####:  260:		ret = -4;
    #####:  261:		goto cleanup;
        -:  262:	}
        -:  263:
        1:  264:	mpxp->x_vals = (float*) malloc(mpxp->drawable_bins * sizeof(float));
        1:  265:	if(!mpxp->x_vals) {
    #####:  266:		ret = -5;
    #####:  267:		goto cleanup;
        -:  268:	}
        -:  269:
        1:  270:	mpxp->y_vals = (float*) malloc(mpxp->drawable_bins * sizeof(float));
        1:  271:	if(!mpxp->y_vals) {
    #####:  272:		ret = -6;
    #####:  273:		goto cleanup;
        -:  274:	}
     1521:  275:	for(i = 0; i < mpxp->drawable_bins; i++)
     1520:  276:		mpxp->y_vals[i] = -1.0;
        -:  277:
        1:  278:	mpxp->y_peak_vals = (float*) malloc(mpxp->drawable_bins * sizeof(float));
        1:  279:	if(!mpxp->y_peak_vals) {
    #####:  280:		ret = -7;
    #####:  281:		goto cleanup;
        -:  282:	}
     1521:  283:	for(i = 0; i < mpxp->drawable_bins; i++)
     1520:  284:		mpxp->y_peak_vals[i] = -1.0;
        -:  285:
        -:  286:	/* Create DFT plan */
        1:  287:	mpxp->dft_plan = fftwf_plan_dft_r2c_1d(mpxp->num_bins, mpxp->real_buff,
        -:  288:					     mpxp->complex_buff, FFTW_MEASURE);
        1:  289:	if(!mpxp->dft_plan) {
    #####:  290:		ret = -8;
    #####:  291:		goto cleanup;
        -:  292:	}
        -:  293:
        -:  294:	/* Initialize x axis and grid points */
        -:  295:	/* Window's coordinates go from -1.0 to +1.0 */
        1:  296:	middle_point = (mpxp->drawable_bins + 1) / 2;
     1521:  297:	for(i = 0; i < mpxp->drawable_bins; i++)
     1520:  298:		mpxp->x_vals[i] = (float)(i - middle_point) /
     1520:  299:				  (float)middle_point;
        -:  300:
        1:  301:	ret = jmrg_mpxp_create_grid_points(mpxp);
        1:  302:	if(ret < 0) {
    #####:  303:		ret = -9;
    #####:  304:		goto cleanup;
        -:  305:	}
        -:  306:
        -:  307:
        -:  308:	/* Create the top level container */
        1:  309:	container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
        1:  310:	if(!container) {
    #####:  311:		ret = -10;
    #####:  312:		goto cleanup; 
        -:  313:	}
        -:  314:
        -:  315:
        -:  316:	/* Create the GtkGLArea and pack it on the box */
        1:  317:	glarea = gtk_gl_area_new();
        1:  318:	if(!glarea) {
    #####:  319:		ret = -11;
    #####:  320:		goto cleanup;
        -:  321:	}
        1:  322:	gtk_box_pack_start(GTK_BOX(container), glarea, 1, 1, 2);
        1:  323:	mpxp->glarea = glarea;
        -:  324:
        -:  325:
        -:  326:	/* Create a new horizonal box for the buttons */
        1:  327:	button_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
        1:  328:	if(!button_box) {
    #####:  329:		ret = -12;
    #####:  330:		goto cleanup;
        -:  331:	}
        1:  332:	gtk_box_pack_start(GTK_BOX(container), button_box, 0, 0, 0);
        -:  333:
        -:  334:	/* Create the two toggle buttons, one for smoothing and one for
        -:  335:	 * max hold */
        1:  336:	avg_tbutton = gtk_toggle_button_new_with_label("Smooth Hold");
        1:  337:	if(!avg_tbutton) {
    #####:  338:		ret = -13;
    #####:  339:		goto cleanup;
        -:  340:	}
        1:  341:	gtk_box_pack_start(GTK_BOX(button_box), avg_tbutton, 1, 1, 2);
        -:  342:
        1:  343:	mh_tbutton = gtk_toggle_button_new_with_label("Max Hold");
        1:  344:	if(!mh_tbutton) {
    #####:  345:		ret = -14;
    #####:  346:		goto cleanup;
        -:  347:	}
        1:  348:	gtk_box_pack_start(GTK_BOX(button_box), mh_tbutton, 1, 1, 2);
        -:  349:
        -:  350:
        -:  351:	/* Register polling function and signal handlers */
        -:  352:
        -:  353:	/* 12FPS -> (1 / 12 * 1000)ms for each frame */
        1:  354:	mpxp->esid = g_timeout_add(83, jmrg_mpxp_redraw, mpxp);
        -:  355:
        -:  356:	/* GL Area */
        1:  357:	g_signal_connect(glarea, "realize", G_CALLBACK(jmrg_mpxp_gl_init), mpxp);
        1:  358:	g_signal_connect(glarea, "render", G_CALLBACK(jmrg_mpxp_gl_render), mpxp);
        -:  359:
        -:  360:	/* Buttons */
        1:  361:	g_signal_connect(avg_tbutton, "toggled", G_CALLBACK(jmrg_mpxp_toggle_avg), mpxp);
        1:  362:	g_signal_connect(mh_tbutton, "toggled", G_CALLBACK(jmrg_mpxp_toggle_mh), mpxp);
        -:  363:
        -:  364:	/* Now register mpxp_destroy as the callback for top level container's
        -:  365:	 * unrealize event */
        1:  366:	g_signal_connect(container, "unrealize", G_CALLBACK(jmrg_mpxp_destroy),
        -:  367:			mpxp);
        -:  368:
        1:  369:	return container;
    #####:  370: cleanup:
    #####:  371:	if(avg_tbutton)
    #####:  372:		gtk_widget_destroy(avg_tbutton);
    #####:  373:	if(button_box)
    #####:  374:		gtk_widget_destroy(button_box);
    #####:  375:	if(glarea)
    #####:  376:		gtk_widget_destroy(glarea);
    #####:  377:	if(container)
    #####:  378:		gtk_widget_destroy(container);
    #####:  379:	jmrg_mpxp_destroy(NULL, mpxp);
    #####:  380:	utils_err("[MPX PLOTTER] Init failed with code: %i\n", ret);
    #####:  381:	return NULL;
        -:  382:}
